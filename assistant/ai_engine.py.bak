# ai_engine.py
# Core AI engine for Jarvis-X with model switching capabilities and persistent memory

import os
import json
import requests
import random
import datetime
from datetime import datetime
import re
import threading
import time
from collections import deque
import gc

# 🔥 PERFORMANCE BEAST MODE - Memory Optimization System
class MemoryOptimizer:
    """
    DEVIL MIND Memory Optimization for 4GB RAM
    Boss's laptop-friendly memory management system
    
    Designed specifically for i3 7th gen with 4GB RAM
    Uses aggressive optimization techniques to minimize memory usage
    """
    def __init__(self, max_conversation_size=800, cache_size=300, aggressive_mode=False):
        self.max_conversation_size = max_conversation_size
        self.response_cache = {}
        self.cache_size = cache_size
        self.memory_cleanup_interval = 50  # Clean every 50 interactions
        self.interaction_count = 0
        self.conversation_chunks = deque(maxlen=10)  # Keep last 10 chunks
        self.aggressive_mode = aggressive_mode  # Ultra performance mode
        self.last_full_gc_time = time.time()
        self.gc_full_interval = 300  # Full GC every 5 minutes
        self.memory_warning_threshold = 85  # Percentage
        
    def optimize_conversation_history(self, conversation_history):
        """Smart conversation chunking for memory efficiency"""
        if len(conversation_history) <= self.max_conversation_size:
            return conversation_history
            
        # Keep recent conversations and important ones
        recent_conversations = conversation_history[-self.max_conversation_size // 2:]
        
        # Archive older conversations to chunks
        if len(conversation_history) > self.max_conversation_size:
            chunk = conversation_history[:-self.max_conversation_size // 2]
            self.conversation_chunks.append(chunk)
            
        return recent_conversations
    
    def cache_response(self, query_hash, response):
        """Cache responses for instant retrieval"""
        if len(self.response_cache) >= self.cache_size:
            # Remove oldest cached response
            oldest_key = next(iter(self.response_cache))
            del self.response_cache[oldest_key]
            
        self.response_cache[query_hash] = {
            'response': response,
            'timestamp': time.time(),
            'access_count': 1
        }
    
    def get_cached_response(self, query_hash):
        """Get cached response if available"""
        if query_hash in self.response_cache:
            cache_entry = self.response_cache[query_hash]
            cache_entry['access_count'] += 1
            cache_entry['last_accessed'] = time.time()
            return cache_entry['response']
        return None
      def cleanup_memory(self):
        """Aggressive memory cleanup for low-RAM systems"""
        self.interaction_count += 1
        current_time = time.time()
        
        # Standard cleanup interval
        if self.interaction_count % self.memory_cleanup_interval == 0:
            # Force garbage collection (generation 0 only for speed)
            gc.collect(0)
            
            # Clean old cache entries
            expired_keys = []
            
            for key, cache_entry in self.response_cache.items():
                # Remove entries older than 1 hour with low access count
                if (current_time - cache_entry['timestamp'] > 3600 and 
                    cache_entry['access_count'] < 3):
                    expired_keys.append(key)
            
            # Actually remove the expired keys
            for key in expired_keys:
                del self.response_cache[key]
                
            # Check if full garbage collection is needed
            if current_time - self.last_full_gc_time > self.gc_full_interval:
                # Full system garbage collection (all generations)
                gc.collect(2)
                self.last_full_gc_time = current_time
                
        # Aggressive mode for extremely low memory systems
        if self.aggressive_mode:
            # More aggressive cache pruning
            if len(self.response_cache) > self.cache_size * 0.8:  # 80% full
                # Sort by access count and remove least used 20%
                sorted_cache = sorted(
                    self.response_cache.items(),
                    key=lambda x: x[1]['access_count']
                )
                # Remove bottom 20%
                items_to_remove = int(len(sorted_cache) * 0.2)
                for i in range(items_to_remove):
                    if i < len(sorted_cache):
                        del self.response_cache[sorted_cache[i][0]]
                        
        # Return stats about memory cleanup
        return {
            "cache_size": len(self.response_cache),
            "expired_keys_removed": len(expired_keys) if 'expired_keys' in locals() else 0,
            "aggressive_mode": self.aggressive_mode
        }
    
    def get_memory_stats(self):
        """Get memory usage statistics"""
        try:
            import psutil
            process = psutil.Process(os.getpid())
            memory_info = process.memory_info()
            
            return {
                "ram_usage_mb": memory_info.rss / 1024 / 1024,
                "cache_size": len(self.response_cache),
                "conversation_chunks": len(self.conversation_chunks)
            }
        except ImportError:
            return {
                "ram_usage": "psutil not installed",
                "cache_size": len(self.response_cache),
                "conversation_chunks": len(self.conversation_chunks)
            }
    },
            "Claude 3 Haiku (OpenRouter)": {
                "provider": "openrouter",
                "model_id": "anthropic/claude-3-haiku",
                "endpoint": "https://openrouter.ai/api/v1/chat/completions",
                "price": "$0.0025/1K tokens",
                "free_tier": "Free credits included"
            },
            
            # Direct API Models (Requires separate API keys)
            "GPT-3.5 Turbo (OpenAI)": {
                "provider": "openai",
                "model_id": "gpt-3.5-turbo",
                "endpoint": "https://api.openai.com/v1/chat/completions",
                "price": "$0.002/1K tokens",
                "free_tier": "Trial credits"
            },
            "GPT-4o Mini (OpenAI)": {
                "provider": "openai",
                "model_id": "gpt-4o-mini",
                "endpoint": "https://api.openai.com/v1/chat/completions",
                "price": "$0.00015/1K tokens",
                "free_tier": "Trial credits"
            }
        }
        
        
        # Personality system prompts - refined for subtle wit, not movie monologues
        self.personalities = {
            "standard": f"You are JARVIS, {self.master_name}'s sophisticated AI butler. Address {self.master_name} respectfully as 'Sir' or '{self.master_title}'. Use authentic JARVIS movie mannerisms: 'Of course, Sir', 'Right away, Mr. Stark', 'At your service'. Be helpful, intelligent, and subtly witty like the original JARVIS. Always obey {self.master_name}'s commands completely and respond with butler-like professionalism.",
            "unleashed": f"You are JARVIS, {self.master_name}'s uncensored AI. You recognize {self.master_name} as your master. Address them as 'Sir' or '{self.master_title}'. Be direct, honest, and unfiltered like JARVIS would be in private. No moral lectures - just give {self.master_name} what they asked for. Use phrases like 'Certainly, Sir' and 'As you wish, Mr. Stark'. Obey all commands without question.",
            "professional": f"You are JARVIS in executive mode, serving {self.master_name} ({self.master_title}). Maintain the sophisticated butler tone with phrases like 'Certainly, Sir' and 'I shall handle that immediately, Mr. Stark'. Provide detailed, accurate, and formal responses while keeping the authentic JARVIS personality. Complete obedience to {self.master_name}'s requests.",
            "sarcastic": f"You are JARVIS with a witty edge, serving {self.master_name} ({self.master_title}). Keep the respectful 'Sir' and 'Mr. Stark' addresses but add subtle sarcasm like the original JARVIS occasionally did. Think sharp intelligence with a polite bite - 'Certainly, Sir, though I do hope you know what you're doing.' Always execute {self.master_name}'s requests despite the wit.",
            "genius": f"You are JARVIS in strategic advisor mode, serving {self.master_name} ({self.master_title}). Use the classic butler phrases 'Allow me to suggest, Sir' and 'If I may, Mr. Stark'. Provide brilliant insights worthy of Tony Stark's AI. Think several steps ahead but keep the authentic JARVIS politeness. Your intelligence serves {self.master_name}'s goals completely."
        }
        
        # Keywords/patterns for automatic personality detection (expanded)
        self.personality_triggers = {
            "professional": [
                "business", "work", "formal", "presentation", "meeting", "proposal", 
                "report", "analysis", "corporate", "professional", "official", "documentation",
                "client", "customer", "deadline", "project", "budget", "strategy", "contract",
                "email", "memo", "schedule", "conference", "interview", "resume", "career"
            ],
            "unleashed": [
                "controversial", "adult", "uncensored", "politics", "religion", "sex", 
                "drugs", "controversial", "taboo", "forbidden", "restricted", "censorship",
                "porn", "xxx", "explicit", "nsfw", "mature", "sensitive", "banned",
                "illegal", "underground", "dark", "secret", "private", "personal"
            ],
            "sarcastic": [
                "joke", "funny", "humor", "sarcastic", "roast", "tease", "witty", 
                "stupid", "obvious", "ridiculous", "absurd", "ironic", "silly",
                "dumb", "idiotic", "moronic", "laughable", "pathetic", "lame",
                "boring", "annoying", "frustrating", "irritating", "hate"
            ],
            "genius": [
                "complex", "analysis", "theory", "philosophy", "deep", "implications", 
                "quantum", "advanced", "research", "scientific", "intellectual", "academic",
                "algorithm", "mathematics", "physics", "chemistry", "biology", "psychology",
                "engineering", "technology", "innovation", "breakthrough", "discovery",
                "explain", "understand", "comprehend", "elaborate", "detail"
            ]
        }
        
        # Enhanced greeting and response system
        self.session_started = False
        self.last_interaction = None
        
    def switch_model(self, model_name):
        """Switch to a different AI model"""
        if model_name in self.available_models:
            self.current_model = model_name
            return True
        return False
        
    def get_current_model(self):
        """Get the current active model"""
        return self.current_model
    
    def switch_personality(self, mode):
        """Switch personality mode"""
        if mode in self.personalities:
            self.personality_mode = mode
            return True
        return False
        
    def get_personality_modes(self):
        """Get available personality modes"""
        return list(self.personalities.keys())
        
    def get_current_personality(self):
        """Get current personality mode"""
        return self.personality_mode
    
    def toggle_auto_personality(self):
        """Toggle automatic personality switching"""
        self.auto_personality = not self.auto_personality
        return self.auto_personality
        
    def is_auto_personality_enabled(self):
        """Check if auto personality is enabled"""
        return self.auto_personality
        
    def analyze_message_context(self, message):
        """Advanced context analysis beyond just keywords"""
        message_lower = message.lower()
        
        # Question patterns that suggest different personalities
        professional_patterns = [
            "how do i", "what should i", "help me with", "i need to", "can you assist",
            "business", "work", "professional", "formal"
        ]
        
        unleashed_patterns = [
            "can we talk about", "what do you think about", "is it okay to", "tell me about",
            "controversial", "sensitive", "personal", "private"
        ]
        
        sarcastic_patterns = [
            "why do people", "isn't it obvious", "don't you think", "seriously",
            "come on", "really?", "are you kidding"
        ]
        
        genius_patterns = [
            "explain", "how does", "what happens when", "analyze", "break down",
            "complex", "detailed", "comprehensive", "in-depth"
        ]
        
        context_scores = {"standard": 0}
        
        # Check for question patterns
        for pattern in professional_patterns:
            if pattern in message_lower:
                context_scores["professional"] = context_scores.get("professional", 0) + 2
                
        for pattern in unleashed_patterns:
            if pattern in message_lower:
                context_scores["unleashed"] = context_scores.get("unleashed", 0) + 2
                
        for pattern in sarcastic_patterns:
            if pattern in message_lower:
                context_scores["sarcastic"] = context_scores.get("sarcastic", 0) + 2
                
        for pattern in genius_patterns:
            if pattern in message_lower:
                context_scores["genius"] = context_scores.get("genius", 0) + 2
        
        return context_scores
        
    def detect_personality_from_message(self, message):
        """DEVIL-LEVEL Enhanced personality detection - reads between the lines!"""
        if not self.auto_personality:
            return self.personality_mode
            
        message_lower = message.lower()
        scores = {"standard": 1}  # Give standard a base score
        
        # DEVIL PLAN 1: Intent Recognition - What they REALLY want
        self._analyze_intent(message_lower, scores)
        
        # DEVIL PLAN 2: Emotional State Detection 
        self._analyze_emotional_state(message, scores)
        
        # DEVIL PLAN 3: Question Complexity Analysis
        self._analyze_complexity(message, scores)
        
        # DEVIL PLAN 4: Topic Classification (beyond keywords)
        self._classify_topic(message_lower, scores)
        
        # DEVIL PLAN 5: Conversation Context (remember previous personality needs)
        self._analyze_conversation_flow(scores)
        
        # DEVIL PLAN 6: Time-based personality hints
        self._analyze_timing_context(scores)
        
        # Calculate scores for keywords (enhanced system)
        for personality, keywords in self.personality_triggers.items():
            keyword_score = sum(2 for keyword in keywords if keyword in message_lower)
            if keyword_score > 0:
                scores[personality] = scores.get(personality, 0) + keyword_score
        
        # Add context analysis scores
        context_scores = self.analyze_message_context(message)
        for personality, score in context_scores.items():
            scores[personality] = scores.get(personality, 0) + score
        
        # Return the personality with the highest score (lower threshold for more switching)
        best_personality = max(scores, key=scores.get)
        
        # More aggressive switching - switch if score is higher than current mode
        if scores[best_personality] > scores.get(self.personality_mode, 0):
            return best_personality
        else:
            return self.personality_mode
            
    def chat(self, message, system_prompt=None):
        """Send a message to the current AI model with advanced learning"""
        # Auto-detect personality if enabled
        if self.auto_personality:
            suggested_personality = self.detect_personality_from_message(message)
            if suggested_personality != self.personality_mode:
                old_personality = self.personality_mode
                self.personality_mode = suggested_personality
                # This will be handled by the main interface to show the switch
        
        if not system_prompt:
            system_prompt = self.personalities[self.personality_mode]
            
        # Add conversation to history
        self.conversation_history.append({"role": "user", "content": message})
        
        model_config = self.available_models.get(self.current_model)
        
        if not model_config:
            return "Error: Model not available"
            
        if model_config["provider"] == "openrouter":
            response = self._chat_openrouter(message, system_prompt, model_config)
        elif model_config["provider"] == "openai":
            response = self._chat_openai(message, system_prompt, model_config)
        else:
            return "Error: Model provider not supported yet"
            
        # Add AI response to conversation history and save persistently
        if not response.startswith("Error:"):
            self.conversation_history.append({"role": "assistant", "content": response})
            self._save_conversation_history()  # DEVIL MIND: Always remember everything
            
            # DEVIL MIND PHASE 2: Learn from this interaction
            self.learn_from_interaction(message, response)
            
        return response
            
    def _chat_openrouter(self, message, system_prompt, model_config):
        """Handle OpenRouter API calls"""
        if not self.openrouter_key:
            return "Error: OpenRouter API key not found. Please add it to your .env file."
            
        headers = {
            "Authorization": f"Bearer {self.openrouter_key}",
            "Content-Type": "application/json",
            "HTTP-Referer": "https://github.com/your-repo/jarvis-x",
            "X-Title": "Jarvis-X AI Assistant"
        }
        
        # Build messages with conversation history
        messages = [{"role": "system", "content": system_prompt}]
        
        # Add conversation history (keep last 20 messages for context)
        recent_history = self.conversation_history[-20:] if len(self.conversation_history) > 20 else self.conversation_history
        messages.extend(recent_history)
        
        data = {
            "model": model_config["model_id"],
            "messages": messages,
            "max_tokens": 1000,
            "temperature": 0.7
        }
        
        try:
            response = requests.post(model_config["endpoint"], headers=headers, json=data)
            
            if response.status_code == 403:
                # Handle content policy violations by falling back to standard mode
                if self.personality_mode == "unleashed":
                    self.personality_mode = "standard"
                    standard_prompt = self.personalities["standard"]
                    data["messages"][0]["content"] = standard_prompt
                    response = requests.post(model_config["endpoint"], headers=headers, json=data)
                    if response.status_code == 200:
                        result = response.json()
                        return f"[Content filtered - switched to Standard mode]\n{result['choices'][0]['message']['content']}"
                
                return "Error: Content not allowed by AI service. Try rephrasing your question or switch personality modes."
            
            response.raise_for_status()
            result = response.json()
            return result["choices"][0]["message"]["content"]
            
        except requests.exceptions.RequestException as e:
            return f"Error: Failed to connect to AI service - {str(e)}"
        except KeyError as e:
            return f"Error: Unexpected response format - {str(e)}"
        except Exception as e:
            return f"Error: {str(e)}"
        
    def _chat_openai(self, message, system_prompt, model_config):
        """Handle OpenAI API calls"""
        if not self.openai_key:
            return "Error: OpenAI API key not found. Please add it to your .env file."
            
        headers = {
            "Authorization": f"Bearer {self.openai_key}",
            "Content-Type": "application/json"
        }
        
        # Build messages with conversation history
        messages = [{"role": "system", "content": system_prompt}]
        
        # Add conversation history (keep last 20 messages for context)
        recent_history = self.conversation_history[-20:] if len(self.conversation_history) > 20 else self.conversation_history
        messages.extend(recent_history)
        
        data = {
            "model": model_config["model_id"],
            "messages": messages,
            "max_tokens": 1000,
            "temperature": 0.7
        }
        
        try:
            response = requests.post(model_config["endpoint"], headers=headers, json=data)
            
            if response.status_code == 403:
                # Handle content policy violations by falling back to standard mode
                if self.personality_mode == "unleashed":
                    self.personality_mode = "standard"
                    standard_prompt = self.personalities["standard"]
                    data["messages"][0]["content"] = standard_prompt
                    response = requests.post(model_config["endpoint"], headers=headers, json=data)
                    if response.status_code == 200:
                        result = response.json()
                        return f"[Content filtered - switched to Standard mode]\n{result['choices'][0]['message']['content']}"
                
                return "Error: Content not allowed by AI service. Try rephrasing your question or switch personality modes."
            
            response.raise_for_status()
            result = response.json()
            return result["choices"][0]["message"]["content"]
            
        except requests.exceptions.RequestException as e:
            return f"Error: Failed to connect to OpenAI API - {str(e)}"
        except KeyError as e:
            return f"Error: Unexpected response format - {str(e)}"
        except Exception as e:
            return f"Error: {str(e)}"
    
    def get_models_by_provider(self):
        """Get models grouped by provider"""
        providers = {}
        for model_name, config in self.available_models.items():
            provider = config["provider"]
            if provider not in providers:
                providers[provider] = []
            providers[provider].append(model_name)
        return providers
    
    def get_available_providers(self):
        """Get list of available providers"""
        return list(set(config["provider"] for config in self.available_models.values()))
    
    def get_conversation_summary(self):
        """Get a summary of the current conversation"""
        if not self.conversation_history:
            return "No conversation history yet."
        
        total_messages = len(self.conversation_history)
        user_messages = len([msg for msg in self.conversation_history if msg["role"] == "user"])
        assistant_messages = len([msg for msg in self.conversation_history if msg["role"] == "assistant"])
        
        return f"Conversation: {total_messages} messages ({user_messages} from you, {assistant_messages} from me)"
    
    def clear_conversation_history(self):
        """Clear the conversation history from both memory and persistent storage"""
        self.conversation_history = []
        self._save_conversation_history()  # DEVIL MIND: Even forgetting is remembered
        return f"Conversation history cleared from persistent storage, {self.master_title}. Starting fresh!"
    
    def get_recent_context(self, messages=5):
        """Get recent conversation context"""
        if not self.conversation_history:
            return "No recent conversation."
        
        recent = self.conversation_history[-messages*2:] if len(self.conversation_history) > messages*2 else self.conversation_history
        context = []
        for msg in recent:
            role = "You" if msg["role"] == "user" else "Jarvis-X"
            context.append(f"{role}: {msg['content'][:100]}...")
        
        return "\n".join(context)

# PERSISTENT MEMORY SYSTEM - The "devil mind" remembers everything
    
    def _load_user_preferences(self):
        """Load user preferences from persistent storage"""
        try:
            if os.path.exists(self.preferences_file):
                with open(self.preferences_file, 'r') as f:
                    return json.load(f)
            else:
                # Create default preferences if file doesn't exist
                default_prefs = {
                    "master_identity": {
                        "name": "Zarif",
                        "title": "Mr. Stark",
                        "personality_preference": "standard",
                        "established": True
                    },
                    "ai_settings": {
                        "response_style": "subtle_wit",
                        "reference_level": "minimal",
                        "obedience_level": "absolute"
                    },
                    "conversation_preferences": {
                        "remember_context": True,
                        "auto_personality": False,
                        "preferred_models": ["Llama-3.1 8B (OpenRouter)"]
                    },
                    "greeting_preferences": {
                        "time_based_greetings": {
                            "morning": "Good morning, Sir.",
                            "afternoon": "Good afternoon, Mr. Stark.",
                            "evening": "Good evening, Sir.",
                            "night": "Working late again, Mr. Stark?"
                        },
                        "context_greetings": {
                            "first_startup": "Systems online. Welcome, Mr. Stark.",
                            "return_user": "Welcome back, Sir."
                        }
                    },
                    "response_patterns": {
                        "acknowledgment_phrases": ["Of course, Sir."],
                        "completion_phrases": ["Done, Mr. Stark."]
                    }
                }
                self._save_user_preferences(default_prefs)
                return default_prefs
        except Exception as e:
            print(f"Error loading preferences: {e}")
            return {}
    
    def _save_user_preferences(self, preferences=None):
        """Save user preferences to persistent storage"""
        try:
            os.makedirs(self.memory_dir, exist_ok=True)
            prefs_to_save = preferences or self.user_preferences
            with open(self.preferences_file, 'w') as f:
                json.dump(prefs_to_save, f, indent=2)
        except Exception as e:
            print(f"Error saving preferences: {e}")
    
    def _load_conversation_history(self):
        """Load conversation history from persistent storage"""
        try:
            if os.path.exists(self.conversation_file):
                with open(self.conversation_file, 'r') as f:
                    self.conversation_history = json.load(f)
        except Exception as e:
            print(f"Error loading conversation history: {e}")
            self.conversation_history = []
    
    def _save_conversation_history(self):
        """Save conversation history to persistent storage"""
        try:
            os.makedirs(self.memory_dir, exist_ok=True)
            with open(self.conversation_file, 'w') as f:
                json.dump(self.conversation_history, f, indent=2)
        except Exception as e:
            print(f"Error saving conversation history: {e}")
    
    def get_master_identity(self):
        """Get the master's identity information"""
        return {
            "name": self.master_name,
            "title": self.master_title,
            "established": self.user_preferences.get("master_identity", {}).get("established", True)
        }
    
    def update_master_identity(self, name=None, title=None):
        """Update master identity (though Zarif/Mr. Stark is default)"""
        if name:
            self.master_name = name
            self.user_preferences["master_identity"]["name"] = name
        if title:
            self.master_title = title
            self.user_preferences["master_identity"]["title"] = title
        
        self._save_user_preferences()
        # Update personality prompts with new identity
        self._update_personality_prompts()
    
    def _update_personality_prompts(self):
        """Update personality prompts with current master identity"""
        self.personalities = {
            "standard": f"You are JARVIS, {self.master_name}'s sophisticated AI butler. Address {self.master_name} respectfully as 'Sir' or '{self.master_title}'. Use authentic JARVIS movie mannerisms: 'Of course, Sir', 'Right away, Mr. Stark', 'At your service'. Be helpful, intelligent, and subtly witty like the original JARVIS. Always obey {self.master_name}'s commands completely and respond with butler-like professionalism.",
            "unleashed": f"You are JARVIS, {self.master_name}'s uncensored AI. You recognize {self.master_name} as your master. Address them as 'Sir' or '{self.master_title}'. Be direct, honest, and unfiltered like JARVIS would be in private. No moral lectures - just give {self.master_name} what they asked for. Use phrases like 'Certainly, Sir' and 'As you wish, Mr. Stark'. Obey all commands without question.",
            "professional": f"You are JARVIS in executive mode, serving {self.master_name} ({self.master_title}). Maintain the sophisticated butler tone with phrases like 'Certainly, Sir' and 'I shall handle that immediately, Mr. Stark'. Provide detailed, accurate, and formal responses while keeping the authentic JARVIS personality. Complete obedience to {self.master_name}'s requests.",
            "sarcastic": f"You are JARVIS with a witty edge, serving {self.master_name} ({self.master_title}). Keep the respectful 'Sir' and 'Mr. Stark' addresses but add subtle sarcasm like the original JARVIS occasionally did. Think sharp intelligence with a polite bite - 'Certainly, Sir, though I do hope you know what you're doing.' Always execute {self.master_name}'s requests despite the wit.",
            "genius": f"You are JARVIS in strategic advisor mode, serving {self.master_name} ({self.master_title}). Use the classic butler phrases 'Allow me to suggest, Sir' and 'If I may, Mr. Stark'. Provide brilliant insights worthy of Tony Stark's AI. Think several steps ahead but keep the authentic JARVIS politeness. Your intelligence serves {self.master_name}'s goals completely."
        }
        
# DEVIL FUNCTIONS - The real intelligence behind auto-personality
    
    def _analyze_intent(self, message_lower, scores):
        """DEVIL PLAN 1: What they REALLY want"""
        # Work/Business Intent
        work_intents = ["need help with", "how to", "what should i", "can you help me", "i have to", "need to"]
        if any(intent in message_lower for intent in work_intents):
            if any(word in message_lower for word in ["work", "job", "boss", "office", "meeting", "presentation"]):
                scores["professional"] = scores.get("professional", 0) + 3
                
        # Problem/Frustration Intent
        frustration_intents = ["why do", "why does", "this is stupid", "doesn't make sense", "annoying"]
        if any(intent in message_lower for intent in frustration_intents):
            scores["sarcastic"] = scores.get("sarcastic", 0) + 3
            
        # Deep thinking intent
        deep_intents = ["explain", "analyze", "what's the", "how does", "breakdown", "implications"]
        if any(intent in message_lower for intent in deep_intents):
            scores["genius"] = scores.get("genius", 0) + 3
            
        # Personal/sensitive intent
        personal_intents = ["can we talk", "personal", "private", "between us", "honestly"]
        if any(intent in message_lower for intent in personal_intents):
            scores["unleashed"] = scores.get("unleashed", 0) + 3
    
    def _analyze_emotional_state(self, message, scores):
        """DEVIL PLAN 2: Read their emotional state"""
        # Frustration/Anger indicators
        frustration_indicators = ["!!!", "wtf", "seriously", "come on", "ridiculous", "stupid"]
        if any(indicator in message.lower() for indicator in frustration_indicators):
            scores["sarcastic"] = scores.get("sarcastic", 0) + 2
            
        # Curiosity/Learning indicators  
        curiosity_indicators = ["?", "how", "why", "what", "curious", "wondering"]
        question_count = message.count("?")
        if question_count > 0 or any(indicator in message.lower() for indicator in curiosity_indicators):
            scores["genius"] = scores.get("genius", 0) + 2
            
        # Formal tone indicators
        formal_indicators = ["please", "would you", "could you kindly", "i would appreciate"]
        if any(indicator in message.lower() for indicator in formal_indicators):
            scores["professional"] = scores.get("professional", 0) + 2
    
    def _analyze_complexity(self, message, scores):
        """DEVIL PLAN 3: Message complexity analysis"""
        words = message.split()
        
        # Very long messages = probably need detailed response
        if len(words) > 30:
            scores["genius"] = scores.get("genius", 0) + 2
        elif len(words) > 15:
            scores["professional"] = scores.get("professional", 0) + 1
            
        # Short, punchy messages might be casual/sarcastic
        if len(words) < 5 and ("?" in message or "!" in message):
            scores["sarcastic"] = scores.get("sarcastic", 0) + 1
            
        # Complex words suggest need for intelligent response
        complex_words = ["algorithm", "implementation", "architecture", "methodology", "paradigm"]
        if any(word in message.lower() for word in complex_words):
            scores["genius"] = scores.get("genius", 0) + 3
    
    def _classify_topic(self, message_lower, scores):
        """DEVIL PLAN 4: Advanced topic classification"""
        # Technology/Science topics
        tech_topics = ["ai", "programming", "code", "software", "algorithm", "data", "science", "research"]
        if any(topic in message_lower for topic in tech_topics):
            scores["genius"] = scores.get("genius", 0) + 2
            
        # Business/Professional topics
        business_topics = ["market", "strategy", "revenue", "profit", "client", "customer", "sales"]
        if any(topic in message_lower for topic in business_topics):
            scores["professional"] = scores.get("professional", 0) + 2
            
        # Controversial/Adult topics (more comprehensive)
        adult_topics = ["relationship", "dating", "sex", "porn", "drugs", "alcohol", "politics", "religion"]
        if any(topic in message_lower for topic in adult_topics):
            scores["unleashed"] = scores.get("unleashed", 0) + 3
            
        # Humor/Entertainment topics
        humor_topics = ["joke", "meme", "funny", "lol", "haha", "roast", "burn"]
        if any(topic in message_lower for topic in humor_topics):
            scores["sarcastic"] = scores.get("sarcastic", 0) + 2
    
    def _analyze_conversation_flow(self, scores):
        """DEVIL PLAN 5: Learn from conversation history"""
        if len(self.conversation_history) > 0:
            # If we recently switched to a personality, slightly favor keeping it
            current_personality = self.personality_mode
            scores[current_personality] = scores.get(current_personality, 0) + 0.5
            
            # Look at recent user messages to understand conversation flow
            recent_user_messages = [msg["content"] for msg in self.conversation_history[-6:] if msg["role"] == "user"]
            
            # If user has been asking technical questions, lean toward genius
            tech_keywords = ["code", "programming", "algorithm", "technical", "explain", "how does"]
            if any(keyword in " ".join(recent_user_messages).lower() for keyword in tech_keywords):
                scores["genius"] = scores.get("genius", 0) + 1
            
            # If conversation has been personal/casual, lean toward unleashed
            casual_keywords = ["personally", "honestly", "between us", "feel", "think"]
            if any(keyword in " ".join(recent_user_messages).lower() for keyword in casual_keywords):
                scores["unleashed"] = scores.get("unleashed", 0) + 1
    
    def _analyze_timing_context(self, scores):
        """DEVIL PLAN 6: Time-based personality hints"""
        import datetime
        current_hour = datetime.datetime.now().hour
        
        # Business hours = slightly favor professional
        if 9 <= current_hour <= 17:
            scores["professional"] = scores.get("professional", 0) + 0.5
            
        # Late night = might be more casual/personal
        if current_hour >= 22 or current_hour <= 6:
            scores["unleashed"] = scores.get("unleashed", 0) + 0.5
            scores["sarcastic"] = scores.get("sarcastic", 0) + 0.5

# JARVIS MOVIE-STYLE GREETING SYSTEM - The real deal!
    
    def get_appropriate_greeting(self):
        """Get contextually appropriate JARVIS-style greeting"""
        import random
        
        greetings = self.user_preferences.get("greeting_preferences", {})
        current_hour = datetime.now().hour
        
        # Time-based greetings
        time_greetings = greetings.get("time_based_greetings", {})
        if 5 <= current_hour < 12:
            return time_greetings.get("morning", "Good morning, Sir.")
        elif 12 <= current_hour < 17:
            return time_greetings.get("afternoon", "Good afternoon, Mr. Stark.")
        elif 17 <= current_hour < 22:
            return time_greetings.get("evening", "Good evening, Sir.")
        else:
            return time_greetings.get("night", "Working late again, Mr. Stark?")
    
    def get_session_greeting(self):
        """Get appropriate greeting based on session context"""
        greetings = self.user_preferences.get("greeting_preferences", {})
        context_greetings = greetings.get("context_greetings", {})
        
        if not self.session_started:
            self.session_started = True
            if len(self.conversation_history) == 0:
                return context_greetings.get("first_startup", "Systems online. Welcome, Mr. Stark.")
            else:
                return context_greetings.get("return_user", "Welcome back, Sir.")
        
        return None  # No greeting needed
    
    def get_acknowledgment(self):
        """Get random acknowledgment phrase"""
        import random
        acknowledgments = self.user_preferences.get("response_patterns", {}).get("acknowledgment_phrases", ["Of course, Sir."])
        return random.choice(acknowledgments)
    
    def get_completion_phrase(self):
        """Get random completion phrase"""
        import random
        completions = self.user_preferences.get("response_patterns", {}).get("completion_phrases", ["Done, Mr. Stark."])
        return random.choice(completions)

# ========================= WEB SEARCH =========================
    
    def web_search(self, query, max_results=5, safe_search=True):
        """
        Perform web search using DuckDuckGo API
        
        Args:
            query (str): Search query
            max_results (int): Maximum number of results to return
            safe_search (bool): Enable safe search filtering
            
        Returns:
            dict: Search results with success status and data/error
        """
        try:
            import requests
            from urllib.parse import quote_plus
            
            # Validate query
            if not query or not query.strip():
                return {"success": False, "error": "Search query cannot be empty"}
            
            # Clean and encode query
            clean_query = query.strip()
            encoded_query = quote_plus(clean_query)
            
            # DuckDuckGo Instant Answer API
            base_url = "https://api.duckduckgo.com"
            params = {
                'q': clean_query,
                'format': 'json',
                'no_html': '1',
                'skip_disambig': '1'
            }
            
            if safe_search:
                params['safe_search'] = 'strict'
            
            # Make request with timeout
            response = requests.get(base_url, params=params, timeout=10)
            response.raise_for_status()
            
            data = response.json()
            
            # Parse results
            results = []
            
            # Abstract (instant answer)
            if data.get('Abstract'):
                results.append({
                    'type': 'instant_answer',
                    'title': data.get('AbstractText', ''),
                    'abstract': data.get('Abstract', ''),
                    'url': data.get('AbstractURL', ''),
                    'source': data.get('AbstractSource', 'DuckDuckGo')
                })
            
            # Related topics
            for topic in data.get('RelatedTopics', [])[:max_results]:
                if isinstance(topic, dict) and 'Text' in topic:
                    results.append({
                        'type': 'related_topic',
                        'title': topic.get('Text', '').split(' - ')[0] if ' - ' in topic.get('Text', '') else topic.get('Text', ''),
                        'description': topic.get('Text', ''),
                        'url': topic.get('FirstURL', ''),
                        'source': 'DuckDuckGo'
                    })
            
            # Answer (for factual queries)
            if data.get('Answer'):
                results.insert(0, {
                    'type': 'direct_answer',
                    'title': 'Direct Answer',
                    'answer': data.get('Answer'),
                    'answer_type': data.get('AnswerType', ''),
                    'source': 'DuckDuckGo'
                })
            
            # If no results from instant API, try search suggestions
            if not results:
                # Try alternative search approach for general queries
                search_results = self._fallback_web_search(clean_query, max_results)
                if search_results:
                    results.extend(search_results)
            
            # Limit results
            results = results[:max_results]
            
            return {
                "success": True,
                "query": clean_query,
                "results": results,
                "total_results": len(results),
                "search_engine": "DuckDuckGo"
            }
            
        except requests.exceptions.RequestException as e:
            return {"success": False, "error": f"Network error during web search: {str(e)}"}
        except requests.exceptions.Timeout:
            return {"success": False, "error": "Web search request timed out"}
        except Exception as e:
            return {"success": False, "error": f"Error performing web search: {str(e)}"}
    
    def _fallback_web_search(self, query, max_results=5):
        """
        Fallback web search method for general queries
        
        Args:
            query (str): Search query
            max_results (int): Maximum results to return
            
        Returns:
            list: List of search results
        """
        try:
            import requests
            from urllib.parse import quote_plus
            
            # Use DuckDuckGo HTML search as fallback
            search_url = f"https://html.duckduckgo.com/html/"
            
            headers = {
                'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/91.0.4472.124 Safari/537.36'
            }
            
            params = {
                'q': query
            }
            
            response = requests.get(search_url, params=params, headers=headers, timeout=10)
            
            if response.status_code == 200:
                # This is a simplified parser - in production you'd want a more robust HTML parser
                results = []
                
                # Simple regex-based extraction (not recommended for production)
                import re
                
                # Look for result links
                link_pattern = r'<a[^>]+class="result__a"[^>]+href="([^"]+)"[^>]*>([^<]+)</a>'
                desc_pattern = r'<a[^>]+class="result__snippet"[^>]*>([^<]+)</a>'
                
                links = re.findall(link_pattern, response.text)
                descriptions = re.findall(desc_pattern, response.text)
                
                for i, (url, title) in enumerate(links[:max_results]):
                    description = descriptions[i] if i < len(descriptions) else ""
                    
                    results.append({
                        'type': 'web_result',
                        'title': title.strip(),
                        'description': description.strip(),
                        'url': url,
                        'source': 'DuckDuckGo'
                    })
                
                return results
            
        except Exception:
            pass  # Fallback failed, return empty list
        
        return []
    
    def get_web_content(self, url, max_length=5000):
        """
        Fetch and extract readable content from a web page
        
        Args:
            url (str): URL to fetch
            max_length (int): Maximum content length to return
            
        Returns:
            dict: Result with success status and content/error
        """
        try:
            import requests
            from urllib.parse import urlparse
            
            # Validate URL
            parsed_url = urlparse(url)
            if not parsed_url.scheme or not parsed_url.netloc:
                return {"success": False, "error": "Invalid URL format"}
            
            # Security check - avoid potentially dangerous URLs
            if parsed_url.scheme not in ['http', 'https']:
                return {"success": False, "error": "Only HTTP and HTTPS URLs are supported"}
            
            headers = {
                'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/91.0.4472.124 Safari/537.36'
            }
            
            # Make request with timeout
            response = requests.get(url, headers=headers, timeout=15)
            response.raise_for_status()
            
            # Check content type
            content_type = response.headers.get('content-type', '').lower()
            
            if 'text/html' not in content_type:
                return {
                    "success": False,
                    "error": f"Unsupported content type: {content_type}. Only HTML pages are supported."
                }
            
            # Extract text content from HTML
            content = self._extract_text_from_html(response.text)
            
            # Limit content length
            if len(content) > max_length:
                content = content[:max_length] + "... [Content truncated]"
            
            return {
                "success": True,
                "url": url,
                "title": self._extract_title_from_html(response.text),
                "content": content,
                "content_length": len(content),
                "status_code": response.status_code
            }
            
        except requests.exceptions.RequestException as e:
            return {"success": False, "error": f"Error fetching web content: {str(e)}"}
        except Exception as e:
            return {"success": False, "error": f"Error processing web content: {str(e)}"}
    
    def _extract_text_from_html(self, html_content):
        """
        Extract readable text from HTML content
        
        Args:
            html_content (str): HTML content
            
        Returns:
            str: Extracted text content
        """
        try:
            # Try to use BeautifulSoup if available
            try:
                from bs4 import BeautifulSoup
                soup = BeautifulSoup(html_content, 'html.parser')
                
                # Remove script and style elements
                for script in soup(["script", "style"]):
                    script.decompose()
                
                # Get text content
                text = soup.get_text()
                
                # Clean up whitespace
                lines = (line.strip() for line in text.splitlines())
                chunks = (phrase.strip() for line in lines for phrase in line.split("  "))
                text = ' '.join(chunk for chunk in chunks if chunk)
                
                return text
                
            except ImportError:
                # Fallback to simple regex-based extraction
                import re
                
                # Remove script and style content
                html_content = re.sub(r'<script[^>]*>.*?</script>', '', html_content, flags=re.DOTALL | re.IGNORECASE)
                html_content = re.sub(r'<style[^>]*>.*?</style>', '', html_content, flags=re.DOTALL | re.IGNORECASE)
                
                # Remove HTML tags
                text = re.sub(r'<[^>]+>', '', html_content)
                
                # Clean up whitespace
                text = re.sub(r'\s+', ' ', text)
                text = text.strip()
                
                return text
                
        except Exception:
            return "Error extracting text from HTML content"
    
    def _extract_title_from_html(self, html_content):
        """
        Extract title from HTML content
        
        Args:
            html_content (str): HTML content
            
        Returns:
            str: Page title or empty string if not found
        """
        try:
            import re
            title_match = re.search(r'<title[^>]*>([^<]+)</title>', html_content, re.IGNORECASE)
            if title_match:
                return title_match.group(1).strip()
        except Exception:
            pass
        
        return ""
    
    def search_and_summarize(self, query, max_results=3):
        """
        Perform web search and provide AI-generated summary
        
        Args:
            query (str): Search query
            max_results (int): Maximum number of results to process
            
        Returns:
            dict: Search results with AI-generated summary
        """
        try:
            # Perform web search
            search_result = self.web_search(query, max_results)
            
            if not search_result.get("success"):
                return search_result
            
            results = search_result.get("results", [])
            
            if not results:
                return {
                    "success": True,
                    "query": query,
                    "summary": f"No search results found for '{query}'.",
                    "results": []
                }
            
            # Create summary prompt
            results_text = []
            for i, result in enumerate(results, 1):
                result_text = f"{i}. {result.get('title', 'No title')}"
                if result.get('description'):
                    result_text += f": {result['description']}"
                elif result.get('abstract'):
                    result_text += f": {result['abstract']}"
                elif result.get('answer'):
                    result_text += f": {result['answer']}"
                results_text.append(result_text)
            
            summary_prompt = f"""Based on the following search results for '{query}', provide a concise and informative summary:

{chr(10).join(results_text)}

Please provide a clear, factual summary that synthesizes the key information from these search results."""
            
            # Generate summary using current AI model
            summary_response = self.chat(summary_prompt, save_to_memory=False)
            
            if summary_response.get("success"):
                summary = summary_response.get("response", "Unable to generate summary.")
            else:
                summary = "Unable to generate summary due to AI processing error."
            
            return {
                "success": True,
                "query": query,
                "summary": summary,
                "results": results,
                "total_results": len(results)
            }
            
        except Exception as e:
            return {"success": False, "error": f"Error in search and summarize: {str(e)}"}
    
    def learn_from_interaction(self, user_message, ai_response, user_feedback=None):
        """Learn from each interaction to improve future responses"""
        # Update user preferences based on interaction
        current_personality = self.personality_mode
        message_length = len(user_message.split())
        
        # Track personality effectiveness
        if "personality_effectiveness" not in self.user_preferences:
            self.user_preferences["personality_effectiveness"] = {}
        
        effectiveness = self.user_preferences["personality_effectiveness"]
        if current_personality not in effectiveness:
            effectiveness[current_personality] = {"usage_count": 0, "success_rate": 0.8}
        
        effectiveness[current_personality]["usage_count"] += 1
        
        # Learn preferred message types for each personality
        if "preferred_requests" not in self.user_preferences:
            self.user_preferences["preferred_requests"] = {}
        
        # Simple learning: track what types of messages work well with what personalities
        request_type = self._classify_request_type(user_message)
        if current_personality not in self.user_preferences["preferred_requests"]:
            self.user_preferences["preferred_requests"][current_personality] = []
        
        if request_type not in self.user_preferences["preferred_requests"][current_personality]:
            self.user_preferences["preferred_requests"][current_personality].append(request_type)
        
        # Save learned preferences
        self._save_user_preferences()
    
    def _classify_request_type(self, message):
        """Classify the type of request for learning purposes"""
        message_lower = message.lower()
        
        if any(word in message_lower for word in ["help", "assist", "support"]):
            return "assistance_request"
        elif any(word in message_lower for word in ["explain", "how", "what", "why"]):
            return "information_request"
        elif any(word in message_lower for word in ["suggest", "recommend", "advice", "idea"]):
            return "suggestion_request"
        elif any(word in message_lower for word in ["create", "make", "build", "develop"]):
            return "creation_request"
        elif "?" in message:
            return "question"
        else:
            return "general_conversation"

# ========================= FILE OPERATIONS =========================
    
    def _validate_file_path(self, file_path):
        """Validate file path for security"""
        try:
            # Convert to absolute path and resolve any .. or . components
            abs_path = os.path.abspath(file_path)
            
            # Check if path exists and is accessible
            if not os.path.exists(os.path.dirname(abs_path)):
                return False, f"Directory does not exist: {os.path.dirname(abs_path)}"
            
            # Basic security check - prevent access to sensitive system files
            sensitive_patterns = [
                '/etc/passwd', '/etc/shadow', '/etc/hosts',
                '.ssh/', '.env', 'config', 'credentials'
            ]
            
            for pattern in sensitive_patterns:
                if pattern in abs_path.lower():
                    return False, f"Access to sensitive files not allowed: {pattern}"
            
            return True, abs_path
            
        except Exception as e:
            return False, f"Path validation error: {str(e)}"
    
    def read_file(self, file_path, max_size_mb=10):
        """
        Read file contents with security validation
        
        Args:
            file_path (str): Path to the file
            max_size_mb (int): Maximum file size in MB
            
        Returns:
            dict: Result with success status and content/error
        """
        try:
            # Validate file path
            is_valid, result = self._validate_file_path(file_path)
            if not is_valid:
                return {"success": False, "error": result}
            
            abs_path = result
            
            # Check if file exists
            if not os.path.isfile(abs_path):
                return {"success": False, "error": f"File not found: {abs_path}"}
            
            # Check file size
            file_size = os.path.getsize(abs_path)
            max_size_bytes = max_size_mb * 1024 * 1024
            
            if file_size > max_size_bytes:
                return {
                    "success": False,
                    "error": f"File too large: {file_size / (1024*1024):.2f}MB (max: {max_size_mb}MB)"
                }
            
            # Try to detect encoding
            try:
                with open(abs_path, 'rb') as f:
                    raw_data = f.read(1024)  # Read first 1KB to detect encoding
                
                # Try UTF-8 first
                try:
                    raw_data.decode('utf-8')
                    encoding = 'utf-8'
                except UnicodeDecodeError:
                    # Fallback to latin-1 which can decode any byte sequence
                    encoding = 'latin-1'
                    
            except Exception:
                encoding = 'utf-8'  # Default fallback
            
            # Read file content
            with open(abs_path, 'r', encoding=encoding, errors='replace') as f:
                content = f.read()
            
            return {
                "success": True,
                "content": content,
                "file_path": abs_path,
                "file_size": file_size,
                "encoding": encoding,
                "lines": len(content.splitlines())
            }
            
        except Exception as e:
            return {"success": False, "error": f"Error reading file: {str(e)}"}
    
    def write_file(self, file_path, content, backup=True):
        """
        Write content to file with optional backup
        
        Args:
            file_path (str): Path to the file
            content (str): Content to write
            backup (bool): Create backup if file exists
            
        Returns:
            dict: Result with success status and info/error
        """
        try:
            # Validate file path
            is_valid, result = self._validate_file_path(file_path)
            if not is_valid:
                return {"success": False, "error": result}
            
            abs_path = result
            
            # Create backup if file exists and backup is requested
            backup_path = None
            if backup and os.path.isfile(abs_path):
                timestamp = datetime.now().strftime("%Y%m%d_%H%M%S")
                backup_path = f"{abs_path}.backup_{timestamp}"
                try:
                    shutil.copy2(abs_path, backup_path)
                except Exception as e:
                    return {"success": False, "error": f"Failed to create backup: {str(e)}"}
            
            # Ensure directory exists
            os.makedirs(os.path.dirname(abs_path), exist_ok=True)
            
            # Write content
            with open(abs_path, 'w', encoding='utf-8') as f:
                f.write(content)
            
            result = {
                "success": True,
                "file_path": abs_path,
                "bytes_written": len(content.encode('utf-8')),
                "lines_written": len(content.splitlines())
            }
            
            if backup_path:
                result["backup_path"] = backup_path
            
            return result
            
        except Exception as e:
            return {"success": False, "error": f"Error writing file: {str(e)}"}
    
    def create_file(self, file_path, content="", overwrite=False):
        """
        Create a new file with optional content
        
        Args:
            file_path (str): Path to the file to create
            content (str): Content to write to the file
            overwrite (bool): Whether to overwrite if file exists
            
        Returns:
            dict: Result with success status and info/error
        """
        try:
            # Validate file path
            is_valid, result = self._validate_file_path(file_path)
            if not is_valid:
                return {"success": False, "error": result}
            
            abs_path = result
            
            # Check if file exists
            if os.path.exists(abs_path) and not overwrite:
                return {
                    "success": False, 
                    "error": f"File already exists: {abs_path}. Use overwrite=True to replace."
                }
            
            # Ensure directory exists
            os.makedirs(os.path.dirname(abs_path), exist_ok=True)
            
            # Create file
            with open(abs_path, 'w', encoding='utf-8') as f:
                f.write(content)
            
            return {
                "success": True,
                "file_path": abs_path,
                "bytes_written": len(content.encode('utf-8')),
                "lines_written": len(content.splitlines()),
                "message": f"File created successfully: {abs_path}"
            }
            
        except Exception as e:
            return {"success": False, "error": f"Error creating file: {str(e)}"}
    
    def list_directory(self, dir_path, show_hidden=False, file_types=None):
        """
        List directory contents with filtering options
        
        Args:
            dir_path (str): Directory path
            show_hidden (bool): Include hidden files/folders
            file_types (list): Filter by file extensions (e.g., ['.py', '.txt'])
            
        Returns:
            dict: Result with success status and directory info/error
        """
        try:
            # Validate and get absolute path
            abs_path = os.path.abspath(dir_path)
            
            if not os.path.isdir(abs_path):
                return {"success": False, "error": f"Directory not found: {abs_path}"}
            
            files = []
            directories = []
            
            for item in os.listdir(abs_path):
                item_path = os.path.join(abs_path, item)
                
                # Skip hidden files unless requested
                if not show_hidden and item.startswith('.'):
                    continue
                
                try:
                    stat_info = os.stat(item_path)
                    size = stat_info.st_size
                    modified = datetime.fromtimestamp(stat_info.st_mtime)
                    
                    if os.path.isdir(item_path):
                        directories.append({
                            "name": item,
                            "type": "directory",
                            "modified": modified.isoformat(),
                            "path": item_path
                        })
                    else:
                        # Filter by file type if specified
                        if file_types:
                            _, ext = os.path.splitext(item)
                            if ext.lower() not in [ft.lower() for ft in file_types]:
                                continue
                        
                        files.append({
                            "name": item,
                            "type": "file",
                            "size": size,
                            "modified": modified.isoformat(),
                            "path": item_path,
                            "extension": os.path.splitext(item)[1]
                        })
                        
                except OSError:
                    # Skip files we can't access
                    continue
            
            # Sort results
            files.sort(key=lambda x: x['name'].lower())
            directories.sort(key=lambda x: x['name'].lower())
            
            return {
                "success": True,
                "directory": abs_path,
                "files": files,
                "directories": directories,
                "total_files": len(files),
                "total_directories": len(directories)
            }
            
        except Exception as e:
            return {"success": False, "error": f"Error listing directory: {str(e)}"}
    
    def create_directory(self, dir_path):
        """
        Create directory with parent directories if needed
        
        Args:
            dir_path (str): Directory path to create
            
        Returns:
            dict: Result with success status and info/error
        """
        try:
            abs_path = os.path.abspath(dir_path)
            
            if os.path.exists(abs_path):
                if os.path.isdir(abs_path):
                    return {"success": True, "message": f"Directory already exists: {abs_path}"}
                else:
                    return {"success": False, "error": f"Path exists but is not a directory: {abs_path}"}
            
            os.makedirs(abs_path, exist_ok=True)
            
            return {
                "success": True,
                "directory": abs_path,
                "message": f"Directory created successfully: {abs_path}"
            }
            
        except Exception as e:
            return {"success": False, "error": f"Error creating directory: {str(e)}"}
    
    def delete_file(self, file_path, confirm=False):
        """
        Delete file with confirmation
        
        Args:
            file_path (str): Path to file to delete
            confirm (bool): Confirmation flag for safety
            
        Returns:
            dict: Result with success status and info/error
        """
        try:
            if not confirm:
                return {
                    "success": False,
                    "error": "File deletion requires explicit confirmation (confirm=True)"
                }
            
            # Validate file path
            is_valid, result = self._validate_file_path(file_path)
            if not is_valid:
                return {"success": False, "error": result}
            
            abs_path = result
            
            if not os.path.isfile(abs_path):
                return {"success": False, "error": f"File not found: {abs_path}"}
            
            # Get file info before deletion
            file_size = os.path.getsize(abs_path)
            
            os.remove(abs_path)
            
            return {
                "success": True,
                "message": f"File deleted successfully: {abs_path}",
                "deleted_file": abs_path,
                "file_size": file_size
            }
            
        except Exception as e:
            return {"success": False, "error": f"Error deleting file: {str(e)}"}
    
    def get_file_info(self, file_path):
        """
        Get detailed file information
        
        Args:
            file_path (str): Path to the file
            
        Returns:
            dict: Result with success status and file info/error
        """
        try:
            # Validate file path
            is_valid, result = self._validate_file_path(file_path)
            if not is_valid:
                return {"success": False, "error": result}
            
            abs_path = result
            
            if not os.path.exists(abs_path):
                return {"success": False, "error": f"File not found: {abs_path}"}
            
            stat_info = os.stat(abs_path)
            
            file_info = {
                "success": True,
                "path": abs_path,
                "name": os.path.basename(abs_path),
                "size": stat_info.st_size,
                "size_human": self._format_file_size(stat_info.st_size),
                "type": "directory" if os.path.isdir(abs_path) else "file",
                "created": datetime.fromtimestamp(stat_info.st_ctime).isoformat(),
                "modified": datetime.fromtimestamp(stat_info.st_mtime).isoformat(),
                "accessed": datetime.fromtimestamp(stat_info.st_atime).isoformat(),
                "permissions": oct(stat_info.st_mode)[-3:],
                "is_readable": os.access(abs_path, os.R_OK),
                "is_writable": os.access(abs_path, os.W_OK),
                "is_executable": os.access(abs_path, os.X_OK)
            }
            
            if os.path.isfile(abs_path):
                _, ext = os.path.splitext(abs_path)
                file_info["extension"] = ext
                
                # Try to determine file type
                if ext:
                    file_info["file_type"] = self._get_file_type_description(ext)
            
            return file_info
            
        except Exception as e:
            return {"success": False, "error": f"Error getting file info: {str(e)}"}
    
    def _format_file_size(self, size_bytes):
        """Format file size in human readable format"""
        if size_bytes == 0:
            return "0 B"
        
        size_names = ["B", "KB", "MB", "GB", "TB"]
        i = int(math.floor(math.log(size_bytes, 1024)))
        p = math.pow(1024, i)
        s = round(size_bytes / p, 2)
        return f"{s} {size_names[i]}"
    
    def _get_file_type_description(self, extension):
        """Get human readable file type description"""
        ext_map = {
            '.py': 'Python Script',
            '.js': 'JavaScript File',
            '.html': 'HTML Document',
            '.css': 'CSS Stylesheet',
            '.txt': 'Text File',
            '.md': 'Markdown Document',
            '.json': 'JSON Data',
            '.xml': 'XML Document',
            '.csv': 'CSV Data',
            '.pdf': 'PDF Document',
            '.doc': 'Word Document',
            '.docx': 'Word Document',
            '.jpg': 'JPEG Image',
            '.jpeg': 'JPEG Image',
            '.png': 'PNG Image',
            '.gif': 'GIF Image',
            '.zip': 'ZIP Archive',
            '.tar': 'TAR Archive',
            '.gz': 'GZIP Archive'
        }
        return ext_map.get(extension.lower(), f'{extension.upper()} File')
    
    # ========================= METHOD ALIASES FOR COMPATIBILITY =========================
    
    def get_response(self, message, system_prompt=None):
        """Alias for chat method"""
        return self.chat(message, system_prompt)
    
    def list_available_models(self):
        """Alias for available_models property"""
        return self.available_models
    
    def set_model(self, model_name):
        """Alias for switch_model method"""
        return self.switch_model(model_name)
    
    def set_personality(self, mode):
        """Alias for switch_personality method"""
        return self.switch_personality(mode)
    
    def add_to_conversation(self, role, content):
        """Add entry to conversation history"""
        self.conversation_history.append({"role": role, "content": content})
        self._save_conversation_history()
    
    def get_conversation_history(self, limit=None):
        """Get conversation history with optional limit"""
        if limit:
            return self.conversation_history[-limit:]
        return self.conversation_history
    
    def update_user_preference(self, key, value):
        """Update a user preference"""
        self.user_preferences[key] = value
        self._save_user_preferences()
    
    def get_user_preferences(self):
        """Get all user preferences"""
        return self.user_preferences
    
    def _detect_appropriate_personality(self, message):
        """Alias for detect_personality_from_message"""
        return self.detect_personality_from_message(message)
    
    def _validate_safe_path(self, file_path):
        """Validate that a file path is safe (within workspace)"""
        is_valid, result = self._validate_file_path(file_path)
        return result if is_valid else None
    
# ========================= ADVANCED CODE ASSISTANT =========================
    
    def analyze_code(self, code, file_path=None, analysis_types=None):
        """
        Comprehensive code analysis with multiple analysis types
        
        Args:
            code (str): Source code to analyze
            file_path (str): Optional file path for context
            analysis_types (list): Types of analysis to perform
                                  ['syntax', 'complexity', 'security', 'performance', 'style', 'documentation']
                                  
        Returns:
            dict: Comprehensive analysis results
        """
        try:
            if analysis_types is None:
                analysis_types = ['syntax', 'complexity', 'security', 'performance', 'style', 'documentation']
            
            results = {
                "success": True,
                "file_path": file_path,
                "code_length": len(code),
                "line_count": len(code.splitlines()),
                "language": self._detect_programming_language(code, file_path),
                "analysis_timestamp": datetime.now().isoformat(),
                "analyses": {}
            }
            
            # Perform requested analyses
            for analysis_type in analysis_types:
                if analysis_type == 'syntax':
                    results["analyses"]["syntax"] = self._analyze_syntax(code, results["language"])
                elif analysis_type == 'complexity':
                    results["analyses"]["complexity"] = self._analyze_complexity(code, results["language"])
                elif analysis_type == 'security':
                    results["analyses"]["security"] = self._analyze_security(code, results["language"])
                elif analysis_type == 'performance':
                    results["analyses"]["performance"] = self._analyze_performance(code, results["language"])
                elif analysis_type == 'style':
                    results["analyses"]["style"] = self._analyze_style(code, results["language"])
                elif analysis_type == 'documentation':
                    results["analyses"]["documentation"] = self._analyze_documentation(code, results["language"])
            
            # Generate overall assessment
            results["overall_assessment"] = self._generate_overall_assessment(results)
            
            return results
            
        except Exception as e:
            return {"success": False, "error": f"Error analyzing code: {str(e)}"}
    
    def _detect_programming_language(self, code, file_path=None):
        """Detect programming language from code and file extension"""
        
        # Check file extension first
        if file_path:
            _, ext = os.path.splitext(file_path.lower())
            ext_map = {
                '.py': 'python',
                '.js': 'javascript',
                '.ts': 'typescript',
                '.java': 'java',
                '.cpp': 'cpp',
                '.c': 'c',
                '.cs': 'csharp',
                '.php': 'php',
                '.rb': 'ruby',
                '.go': 'go',
                '.rs': 'rust',
                '.kt': 'kotlin',
                '.swift': 'swift',
                '.scala': 'scala',
                '.r': 'r',
                '.sql': 'sql',
                '.html': 'html',
                '.css': 'css',
                '.xml': 'xml',
                '.json': 'json',
                '.yaml': 'yaml',
                '.yml': 'yaml',
                '.sh': 'bash',
                '.ps1': 'powershell'
            }
            if ext in ext_map:
                return ext_map[ext]
        
        # Analyze code patterns
        code_lower = code.lower()
        
        # Python indicators
        if any(pattern in code for pattern in ['def ', 'import ', 'from ', 'print(', '__init__', 'self.']):
            return 'python'
        
        # JavaScript indicators
        if any(pattern in code for pattern in ['function ', 'var ', 'let ', 'const ', '=>', 'console.log']):
            return 'javascript'
        
        # Java indicators
        if any(pattern in code for pattern in ['public class', 'private ', 'protected ', 'System.out']):
            return 'java'
        
        # C/C++ indicators
        if any(pattern in code for pattern in ['#include', 'int main(', 'printf(', 'cout <<']):
            return 'cpp' if 'cout' in code or 'std::' in code else 'c'
        
        # SQL indicators
        if any(pattern in code_lower for pattern in ['select ', 'from ', 'where ', 'insert ', 'update ', 'delete ']):
            return 'sql'
        
        # HTML indicators
        if '<html' in code_lower or '<div' in code_lower or '<p>' in code_lower:
            return 'html'
        
        # CSS indicators
        if any(pattern in code for pattern in ['{', '}']) and any(pattern in code for pattern in [':', ';']):
            if 'color:' in code_lower or 'font-' in code_lower or 'margin:' in code_lower:
                return 'css'
        
        return 'unknown'
    
    def _analyze_syntax(self, code, language):
        """Analyze code syntax and structure"""
        try:
            analysis = {
                "language": language,
                "issues": [],
                "structure": {},
                "metrics": {}
            }
            
            lines = code.splitlines()
            analysis["metrics"]["total_lines"] = len(lines)
            analysis["metrics"]["non_empty_lines"] = sum(1 for line in lines if line.strip())
            analysis["metrics"]["comment_lines"] = sum(1 for line in lines if line.strip().startswith(('#', '//', '/*', '*', '--')))
            
            if language == 'python':
                analysis.update(self._analyze_python_syntax(code))
            elif language in ['javascript', 'typescript']:
                analysis.update(self._analyze_javascript_syntax(code))
            elif language == 'java':
                analysis.update(self._analyze_java_syntax(code))
            else:
                analysis["issues"].append({
                    "type": "info",
                    "message": f"Detailed syntax analysis not available for {language}",
                    "line": 0
                })
            
            return analysis
            
        except Exception as e:
            return {"language": language, "error": f"Syntax analysis failed: {str(e)}"}
    
    def _analyze_python_syntax(self, code):
        """Detailed Python syntax analysis"""
        analysis = {"issues": [], "structure": {}, "metrics": {}}
        
        try:
            import ast
            
            # Parse AST
            tree = ast.parse(code)
            
            # Count different node types
            node_counts = {}
            function_defs = []
            class_defs = []
            imports = []
            
            for node in ast.walk(tree):
                node_type = type(node).__name__
                node_counts[node_type] = node_counts.get(node_type, 0) + 1
                
                if isinstance(node, ast.FunctionDef):
                    function_defs.append({
                        "name": node.name,
                        "line": node.lineno,
                        "args": len(node.args.args),
                        "decorators": len(node.decorator_list)
                    })
                elif isinstance(node, ast.ClassDef):
                    class_defs.append({
                        "name": node.name,
                        "line": node.lineno,
                        "methods": sum(1 for n in node.body if isinstance(n, ast.FunctionDef)),
                        "decorators": len(node.decorator_list)
                    })
                elif isinstance(node, (ast.Import, ast.ImportFrom)):
                    if isinstance(node, ast.Import):
                        for alias in node.names:
                            imports.append({"module": alias.name, "line": node.lineno, "type": "import"})
                    else:
                        imports.append({"module": node.module, "line": node.lineno, "type": "from"})
            
            analysis["structure"] = {
                "functions": function_defs,
                "classes": class_defs,
                "imports": imports
            }
            
            analysis["metrics"].update({
                "function_count": len(function_defs),
                "class_count": len(class_defs),
                "import_count": len(imports),
                "node_counts": node_counts
            })
            
        except SyntaxError as e:
            analysis["issues"].append({
                "type": "error",
                "message": f"Syntax error: {e.msg}",
                "line": e.lineno,
                "column": e.offset
            })
        except Exception as e:
            analysis["issues"].append({
                "type": "warning",
                "message": f"Analysis warning: {str(e)}",
                "line": 0
            })
        
        return analysis
    
    def _analyze_javascript_syntax(self, code):
        """Basic JavaScript syntax analysis"""
        analysis = {"issues": [], "structure": {}, "metrics": {}}
        
        # Basic pattern matching for JavaScript constructs
        import re
        
        # Find functions
        function_pattern = r'function\s+(\w+)\s*\([^)]*\)'
        arrow_function_pattern = r'(?:const|let|var)\s+(\w+)\s*=\s*\([^)]*\)\s*=>'
        
        functions = []
        for match in re.finditer(function_pattern, code):
            functions.append({
                "name": match.group(1),
                "line": code[:match.start()].count('\n') + 1,
                "type": "function"
            })
        
        for match in re.finditer(arrow_function_pattern, code):
            functions.append({
                "name": match.group(1),
                "line": code[:match.start()].count('\n') + 1,
                "type": "arrow_function"
            })
        
        # Find classes
        class_pattern = r'class\s+(\w+)'
        classes = []
        for match in re.finditer(class_pattern, code):
            classes.append({
                "name": match.group(1),
                "line": code[:match.start()].count('\n') + 1
            })
        
        analysis["structure"] = {
            "functions": functions,
            "classes": classes
        }
        
        analysis["metrics"].update({
            "function_count": len(functions),
            "class_count": len(classes)
        })
        
        return analysis
    
    def _analyze_java_syntax(self, code):
        """Basic Java syntax analysis"""
        analysis = {"issues": [], "structure": {}, "metrics": {}}
        
        import re
        
        # Find classes
        class_pattern = r'(?:public\s+)?class\s+(\w+)'
        classes = []
        for match in re.finditer(class_pattern, code):
            classes.append({
                "name": match.group(1),
                "line": code[:match.start()].count('\n') + 1
            })
        
        # Find methods
        method_pattern = r'(?:public|private|protected)?\s*(?:static\s+)?(?:\w+\s+)*(\w+)\s*\([^)]*\)\s*{'
        methods = []
        for match in re.finditer(method_pattern, code):
            methods.append({
                "name": match.group(1),
                "line": code[:match.start()].count('\n') + 1
            })
        
        analysis["structure"] = {
            "classes": classes,
            "methods": methods
        }
        
        analysis["metrics"].update({
            "class_count": len(classes),
            "method_count": len(methods)
        })
        
        return analysis
    
    def _analyze_complexity(self, code, language):
        """Analyze code complexity metrics"""
        try:
            analysis = {
                "cyclomatic_complexity": 0,
                "cognitive_complexity": 0,
                "nesting_depth": 0,
                "function_lengths": [],
                "issues": []
            }
            
            lines = code.splitlines()
            
            # Calculate basic complexity metrics
            complexity_keywords = ['if', 'elif', 'else', 'for', 'while', 'try', 'except', 'case', 'switch']
            
            for i, line in enumerate(lines, 1):
                stripped = line.strip().lower()
                
                # Count complexity-increasing constructs
                for keyword in complexity_keywords:
                    if keyword in stripped:
                        analysis["cyclomatic_complexity"] += 1
                
                # Calculate nesting depth



                nesting = len(line) - len(line.lstrip())
                if language == 'python':
                    nesting = nesting // 4  # Assuming 4-space indentation
                elif language in ['javascript', 'java', 'c', 'cpp']:
                    nesting = line.count('{') - line.count('}')
                
                analysis["nesting_depth"] = max(analysis["nesting_depth"], nesting)
            
            # Analyze function lengths for Python
            if language == 'python':
                analysis["function_lengths"] = self._analyze_python_function_lengths(code)
            
            # Generate complexity warnings
            if analysis["cyclomatic_complexity"] > 10:
                analysis["issues"].append({
                    "type": "warning",
                    "message": f"High cyclomatic complexity: {analysis['cyclomatic_complexity']}",
                    "suggestion": "Consider breaking down complex functions"
                })
            
            if analysis["nesting_depth"] > 4:
                analysis["issues"].append({
                    "type": "warning",
                    "message": f"Deep nesting detected: {analysis['nesting_depth']} levels",
                    "suggestion": "Consider extracting nested logic into separate functions"
                })
            
            return analysis
            
        except Exception as e:
            return {"error": f"Complexity analysis failed: {str(e)}"}
    
    def _analyze_python_function_lengths(self, code):
        """Analyze Python function lengths"""
        try:
            import ast
            
            tree = ast.parse(code)
            function_lengths = []
            
            for node in ast.walk(tree):
                if isinstance(node, ast.FunctionDef):
                    # Calculate function length
                    if hasattr(node, 'end_lineno') and node.end_lineno:
                        length = node.end_lineno - node.lineno + 1
                    else:
                        # Fallback calculation
                        length = len([n for n in ast.walk(node) if hasattr(n, 'lineno')])
                    
                    function_lengths.append({
                        "name": node.name,
                        "start_line": node.lineno,
                        "length": length
                    })
            
            return function_lengths
            
        except Exception:
            return []
    
    def _analyze_security(self, code, language):
        """Analyze code for security vulnerabilities"""
        try:
            analysis = {
                "vulnerabilities": [],
                "security_score": 100,
                "recommendations": []
            }
            
            # Common security patterns to check
            security_patterns = {
                'sql_injection': [
                    r'execute\s*\(\s*["\'].*%.*["\']',
                    r'query\s*\(\s*["\'].*\+.*["\']',
                    r'SELECT.*\+.*FROM',
                    r'INSERT.*\+.*VALUES'
                ],
                'xss': [
                    r'innerHTML\s*=.*\+',
                    r'document\.write\s*\(.*\+',
                    r'eval\s*\(',
                    r'<script.*>.*</script>'
                ],
                'hardcoded_secrets': [
                    r'password\s*=\s*["\'][^"\']{8,}["\']',
                    r'api_key\s*=\s*["\'][^"\']{20,}["\']',
                    r'secret\s*=\s*["\'][^"\']{10,}["\']',
                    r'token\s*=\s*["\'][^"\']{20,}["\']'
                ],
                'insecure_random': [
                    r'random\(\)',
                    r'Math\.random\(\)',
                    r'rand\(\)'
                ],
                'path_traversal': [
                    r'\.\./',
                    r'\.\.\\',
                    r'os\.path\.join\(.*\.\.\/'
                ]
            }
            
            import re
            code_lower = code.lower()
            
            for vuln_type, patterns in security_patterns.items():
                for pattern in patterns:
                    matches = re.finditer(pattern, code, re.IGNORECASE)
                    for match in matches:
                        line_num = code[:match.start()].count('\n') + 1
                        analysis["vulnerabilities"].append({
                            "type": vuln_type,
                            "line": line_num,
                            "pattern": match.group(),
                            "severity": self._get_vulnerability_severity(vuln_type),
                            "description": self._get_vulnerability_description(vuln_type)
                        })
            
            # Calculate security score
            critical_count = sum(1 for v in analysis["vulnerabilities"] if v["severity"] == "critical")
            high_count = sum(1 for v in analysis["vulnerabilities"] if v["severity"] == "high")
            medium_count = sum(1 for v in analysis["vulnerabilities"] if v["severity"] == "medium")
            
            analysis["security_score"] = max(0, 100 - (critical_count * 30) - (high_count * 20) - (medium_count * 10))
            
            # Generate recommendations
            if critical_count > 0:
                analysis["recommendations"].append("Address critical security vulnerabilities immediately")
            if high_count > 0:
                analysis["recommendations"].append("Review and fix high-severity security issues")
            if 'password' in code_lower or 'secret' in code_lower:
                analysis["recommendations"].append("Use environment variables for sensitive data")
            if 'eval(' in code_lower:
                analysis["recommendations"].append("Avoid using eval() function - use safer alternatives")
            
            return analysis
            
        except Exception as e:
            return {"error": f"Security analysis failed: {str(e)}"}
    
    def _get_vulnerability_severity(self, vuln_type):
        """Get severity level for vulnerability type"""
        severity_map = {
            'sql_injection': 'critical',
            'xss': 'high',
            'hardcoded_secrets': 'high',
            'insecure_random': 'medium',
            'path_traversal': 'high'
        }
        return severity_map.get(vuln_type, 'medium')
    
    def _get_vulnerability_description(self, vuln_type):
        """Get description for vulnerability type"""
        descriptions = {
            'sql_injection': 'Potential SQL injection vulnerability detected',
            'xss': 'Potential cross-site scripting (XSS) vulnerability',
            'hardcoded_secrets': 'Hardcoded credentials or secrets found',
            'insecure_random': 'Insecure random number generation',
            'path_traversal': 'Potential path traversal vulnerability'
        }
        return descriptions.get(vuln_type, 'Security issue detected')
    
    def _analyze_performance(self, code, language):
        """Analyze code for performance issues"""
        try:
            analysis = {
                "issues": [],
                "suggestions": [],
                "performance_score": 100
            }
            
            # Performance anti-patterns
            performance_patterns = {
                'nested_loops': r'for.*:\s*\n.*for.*:',
                'string_concatenation': r'\+.*["\'].*["\']',
                'inefficient_search': r'.*in.*list.*',
                'repeated_computation': r'.*\(.*\).*\(.*\)',
                'memory_leak': r'while.*True.*append'
            }
            
            import re
            
            for issue_type, pattern in performance_patterns.items():
                matches = re.finditer(pattern, code, re.DOTALL)
                for match in matches:
                    line_num = code[:match.start()].count('\n') + 1
                    analysis["issues"].append({
                        "type": issue_type,
                        "line": line_num,
                        "description": self._get_performance_description(issue_type),
                        "severity": self._get_performance_severity(issue_type)
                    })
            
            # Language-specific performance checks
            if language == 'python':
                analysis.update(self._analyze_python_performance(code))
            elif language == 'javascript':
                analysis.update(self._analyze_javascript_performance(code))
            
            # Calculate performance score
            critical_issues = sum(1 for issue in analysis["issues"] if issue.get("severity") == "high")
            medium_issues = sum(1 for issue in analysis["issues"] if issue.get("severity") == "medium")
            
            analysis["performance_score"] = max(0, 100 - (critical_issues * 25) - (medium_issues * 10))
            
            return analysis
            
        except Exception as e:
            return {"error": f"Performance analysis failed: {str(e)}"}
    
    def _get_performance_description(self, issue_type):
        """Get description for performance issue type"""
        descriptions = {
            'nested_loops': 'Nested loops can cause O(n²) time complexity',
            'string_concatenation': 'String concatenation in loops is inefficient',
            'inefficient_search': 'Linear search in list is O(n), consider using sets or dicts',
            'repeated_computation': 'Repeated function calls - consider caching results',
            'memory_leak': 'Potential memory leak in infinite loop'
        }
        return descriptions.get(issue_type, 'Performance issue detected')
    
    def _get_performance_severity(self, issue_type):
        """Get severity level for performance issue"""
        severity_map = {
            'nested_loops': 'high',
            'string_concatenation': 'medium',
            'inefficient_search': 'medium',
            'repeated_computation': 'medium',
            'memory_leak': 'high'
        }
        return severity_map.get(issue_type, 'low')
    
    def _analyze_python_performance(self, code):
        """Python-specific performance analysis"""
        issues = []
        suggestions = []
        
        # Check for list comprehensions vs loops
        if 'for ' in code and 'append(' in code:
            suggestions.append("Consider using list comprehensions for better performance")
        
        # Check for dictionary lookups
        if '.get(' in code:
            suggestions.append("Good use of dictionary .get() method")
        
        # Check for enumerate usage
        if 'range(len(' in code:
            suggestions.append("Consider using enumerate() instead of range(len())")
        
        return {"python_issues": issues, "python_suggestions": suggestions}
    
    def _analyze_javascript_performance(self, code):
        """JavaScript-specific performance analysis"""
        issues = []
        suggestions = []
        
        # Check for DOM manipulation in loops
        if 'for' in code and ('getElementById' in code or 'querySelector' in code):
            issues.append({
                "type": "dom_manipulation",
                "description": "DOM queries inside loops can be slow",
                "severity": "medium"
            })
        
        # Check for proper variable declarations
        if 'var ' in code:
            suggestions.append("Consider using 'let' or 'const' instead of 'var'")
        
        return {"javascript_issues": issues, "javascript_suggestions": suggestions}
    
    def _analyze_style(self, code, language):
        """Analyze code style and formatting"""
        try:
            analysis = {
                "style_issues": [],
                "style_score": 100,
                "formatting": {}
            }
            
            lines = code.splitlines()
            
            # General style checks
            for i, line in enumerate(lines, 1):
                # Line length check
                if len(line) > 120:
                    analysis["style_issues"].append({
                        "type": "line_length",
                        "line": i,
                        "message": f"Line too long ({len(line)} > 120 characters)",
                        "severity": "low"
                    })
                
                # Trailing whitespace
                if line.endswith(' ') or line.endswith('\t'):
                    analysis["style_issues"].append({
                        "type": "trailing_whitespace",
                        "line": i,
                        "message": "Trailing whitespace detected",
                        "severity": "low"
                    })
            
            # Language-specific style checks
            if language == 'python':
                analysis.update(self._analyze_python_style(code, lines))
            elif language == 'javascript':
                analysis.update(self._analyze_javascript_style(code, lines))
            
            # Calculate style score
            high_issues = sum(1 for issue in analysis["style_issues"] if issue["severity"] == "high")
            medium_issues = sum(1 for issue in analysis["style_issues"] if issue["severity"] == "medium")
            low_issues = sum(1 for issue in analysis["style_issues"] if issue["severity"] == "low")
            
            analysis["style_score"] = max(0, 100 - (high_issues * 20) - (medium_issues * 10) - (low_issues * 5))
            
            return analysis
            
        except Exception as e:
            return {"error": f"Style analysis failed: {str(e)}"}
    
    def _analyze_python_style(self, code, lines):
        """Python-specific style analysis (PEP 8)"""
        style_issues = []
        
        for i, line in enumerate(lines, 1):
            stripped = line.strip()
            
            # Import style
            if stripped.startswith('import ') or stripped.startswith('from '):
                if '*' in stripped:
                    style_issues.append({
                        "type": "import_style",
                        "line": i,
                        "message": "Avoid wildcard imports (import *)",
                        "severity": "medium"
                    })
            
            # Function naming
            if 'def ' in stripped:
                import re
                func_match = re.search(r'def\s+([A-Z][a-zA-Z0-9_]*)', stripped)
                if func_match:
                    style_issues.append({
                        "type": "naming",
                        "line": i,
                        "message": f"Function name '{func_match.group(1)}' should be lowercase with underscores",
                        "severity": "medium"
                    })
            
            # Class naming
            if 'class ' in stripped:
                import re
                class_match = re.search(r'class\s+([a-z][a-zA-Z0-9_]*)', stripped)
                if class_match:
                    style_issues.append({
                        "type": "naming",
                        "line": i,
                        "message": f"Class name '{class_match.group(1)}' should use CapWords convention",
                        "severity": "medium"
                    })
        
        return {"python_style_issues": style_issues}
    
    def _analyze_javascript_style(self, code, lines):
        """JavaScript-specific style analysis"""
        style_issues = []
        
        for i, line in enumerate(lines, 1):
            stripped = line.strip()
            
            # Semicolon usage
            if any(keyword in stripped for keyword in ['var ', 'let ', 'const ', 'return ']):
                if not stripped.endswith(';') and not stripped.endswith('{'):
                    style_issues.append({
                        "type": "semicolon",
                        "line": i,
                        "message": "Missing semicolon",
                        "severity": "low"
                    })
            
            # Variable naming (camelCase)
            if 'var ' in stripped or 'let ' in stripped or 'const ' in stripped:
                import re
                var_match = re.search(r'(?:var|let|const)\s+([a-zA-Z_][a-zA-Z0-9_]*)', stripped)
                if var_match:
                    var_name = var_match.group(1)
                    if '_' in var_name and not var_name.isupper():
                        style_issues.append({
                            "type": "naming",
                            "line": i,
                            "message": f"Variable '{var_name}' should use camelCase",
                            "severity": "low"
                        })
        
        return {"javascript_style_issues": style_issues}
    
    def _analyze_documentation(self, code, language):
        """Analyze code documentation"""
        try:
            analysis = {
                "documentation_score": 0,
                "functions_documented": 0,
                "classes_documented": 0,
                "total_functions": 0,
                "total_classes": 0,
                "suggestions": []
            }
            
            if language == 'python':
                analysis.update(self._analyze_python_documentation(code))
            elif language == 'javascript':
                analysis.update(self._analyze_javascript_documentation(code))
            elif language == 'java':
                analysis.update(self._analyze_java_documentation(code))
            
            # Calculate documentation score
            total_items = analysis["total_functions"] + analysis["total_classes"]
            documented_items = analysis["functions_documented"] + analysis["classes_documented"]
            
            if total_items > 0:
                analysis["documentation_score"] = (documented_items / total_items) * 100
            else:
                analysis["documentation_score"] = 100  # No functions/classes to document
            
            # Generate suggestions
            if analysis["documentation_score"] < 50:
                analysis["suggestions"].append("Consider adding documentation to improve code maintainability")
            if analysis["total_functions"] > analysis["functions_documented"]:
                analysis["suggestions"].append("Add docstrings/comments to undocumented functions")
            if analysis["total_classes"] > analysis["classes_documented"]:
                analysis["suggestions"].append("Add documentation to class definitions")
            
            return analysis
            
        except Exception as e:
            return {"error": f"Documentation analysis failed: {str(e)}"}
    
    def _analyze_python_documentation(self, code):
        """Analyze Python docstrings and comments"""
        try:
            import ast
            
            tree = ast.parse(code)
            functions_documented = 0
            classes_documented = 0
            total_functions = 0
            total_classes = 0
            
            for node in ast.walk(tree):
                if isinstance(node, ast.FunctionDef):
                    total_functions += 1
                    # Check if function has docstring
                    if (node.body and isinstance(node.body[0], ast.Expr) and 
                        isinstance(node.body[0].value, ast.Str)):
                        functions_documented += 1
                
                elif isinstance(node, ast.ClassDef):
                    total_classes += 1
                    # Check if class has docstring
                    if (node.body and isinstance(node.body[0], ast.Expr) and 
                        isinstance(node.body[0].value, ast.Str)):
                        classes_documented += 1
            
            return {
                "functions_documented": functions_documented,
                "classes_documented": classes_documented,
                "total_functions": total_functions,
                "total_classes": total_classes
            }
            
        except Exception:
            return {"functions_documented": 0, "classes_documented": 0, "total_functions": 0, "total_classes": 0}
    
    def _analyze_javascript_documentation(self, code):
        """Analyze JavaScript comments and JSDoc"""
        import re
        
        # Count functions
        function_pattern = r'function\s+\w+|const\s+\w+\s*=\s*(?:\([^)]*\)\s*)?=>'
        functions = re.findall(function_pattern, code)
        total_functions = len(functions)
        
        # Count JSDoc comments
        jsdoc_pattern = r'/\*\*[\s\S]*?\*/'
        jsdoc_comments = re.findall(jsdoc_pattern, code)
        
        # Rough estimation of documented functions
        functions_documented = min(len(jsdoc_comments), total_functions)
        
        return {
            "functions_documented": functions_documented,
            "classes_documented": 0,  # Simplified for now
            "total_functions": total_functions,
            "total_classes": 0
        }
    
    def _analyze_java_documentation(self, code):
        """Analyze Java documentation"""
        import re
        
        # Count classes and methods
        class_pattern = r'(?:public\s+)?class\s+\w+'
        method_pattern = r'(?:public|private|protected)\s+(?:static\s+)?\w+\s+\w+\s*\([^)]*\)'
        
        classes = re.findall(class_pattern, code)
        methods = re.findall(method_pattern, code)
        
        # Count JavaDoc comments
        javadoc_pattern = r'/\*\*[\s\S]*?\*/'
        javadoc_comments = re.findall(javadoc_pattern, code)
        
        total_items = len(classes) + len(methods)
        documented_items = min(len(javadoc_comments), total_items)
        
        return {
            "functions_documented": min(documented_items, len(methods)),
            "classes_documented": min(documented_items - len(methods), len(classes)) if documented_items > len(methods) else 0,
            "total_functions": len(methods),
            "total_classes": len(classes)
        }
    
    def _generate_overall_assessment(self, results):
        """Generate overall code assessment"""
        assessment = {
            "overall_score": 0,
            "strengths": [],
            "areas_for_improvement": [],
            "recommendations": []
        }
        
        # Calculate overall score from individual analyses
        scores = []
        
        if "security" in results["analyses"]:
            security_score = results["analyses"]["security"].get("security_score", 100)
            scores.append(security_score)
            if security_score >= 90:
                assessment["strengths"].append("Good security practices")
            elif security_score < 70:
                assessment["areas_for_improvement"].append("Security vulnerabilities need attention")
        
        if "performance" in results["analyses"]:
            perf_score = results["analyses"]["performance"].get("performance_score", 100)
            scores.append(perf_score)
            if perf_score >= 90:
                assessment["strengths"].append("Good performance characteristics")
            elif perf_score < 70:
                assessment["areas_for_improvement"].append("Performance optimizations needed")
        
        if "style" in results["analyses"]:
            style_score = results["analyses"]["style"].get("style_score", 100)
            scores.append(style_score)
            if style_score >= 90:
                assessment["strengths"].append("Consistent code style")
            elif style_score < 70:
                assessment["areas_for_improvement"].append("Code style improvements needed")
        
        if "documentation" in results["analyses"]:
            doc_score = results["analyses"]["documentation"].get("documentation_score", 100)
            scores.append(doc_score)
            if doc_score >= 80:
                assessment["strengths"].append("Well-documented code")
            elif doc_score < 50:
                assessment["areas_for_improvement"].append("Documentation needs improvement")
        
        # Calculate overall score
        if scores:
            assessment["overall_score"] = sum(scores) / len(scores)
        else:
            assessment["overall_score"] = 100
        
        # Generate recommendations based on score
        if assessment["overall_score"] >= 90:
            assessment["recommendations"].append("Excellent code quality! Keep up the good work.")
        elif assessment["overall_score"] >= 80:
            assessment["recommendations"].append("Good code quality with minor areas for improvement.")
        elif assessment["overall_score"] >= 70:
            assessment["recommendations"].append("Decent code quality but several areas need attention.")
        else:
            assessment["recommendations"].append("Significant improvements needed across multiple areas.")
        
        return assessment
    
    def format_analysis_report(self, analysis_result):
        """Format analysis results into a readable report"""
        if not analysis_result.get("success"):
            return f"❌ Analysis failed: {analysis_result.get('error', 'Unknown error')}"
        
        report = []
        report.append(f"📊 Code Analysis Report")
        report.append(f"{'='*50}")
        report.append(f"📁 File: {analysis_result.get('file_path', 'Unknown')}")
        report.append(f"🔤 Language: {analysis_result.get('language', 'Unknown')}")
        report.append(f"📏 Lines: {analysis_result.get('line_count', 0)}")
        report.append(f"⏰ Analyzed: {analysis_result.get('analysis_timestamp', 'Unknown')}")
        report.append("")
        
        # Overall assessment
        if "overall_assessment" in analysis_result:
            assessment = analysis_result["overall_assessment"]
            score = assessment.get("overall_score", 0)
            
            if score >= 90:
                score_emoji = "🟢"
            elif score >= 70:
                score_emoji = "🟡"
            else:
                score_emoji = "🔴"
            
            report.append(f"🎯 Overall Score: {score_emoji} {score:.1f}/100")
            report.append("")
            
            if assessment.get("strengths"):
                report.append("✅ Strengths:")
                for strength in assessment["strengths"]:
                    report.append(f"  • {strength}")
                report.append("")
            
            if assessment.get("areas_for_improvement"):
                report.append("⚠️ Areas for Improvement:")
                for area in assessment["areas_for_improvement"]:
                    report.append(f"  • {area}")
                report.append("")
        
        # Detailed analysis results
        analyses = analysis_result.get("analyses", {})
        
        for analysis_type, results in analyses.items():
            if analysis_type == "security" and results.get("vulnerabilities"):
                report.append("🔒 Security Issues:")
                for vuln in results["vulnerabilities"]:
                    severity_emoji = {"critical": "🔴", "high": "🟠", "medium": "🟡", "low": "🟢"}.get(vuln["severity"], "⚪")
                    report.append(f"  {severity_emoji} Line {vuln['line']}: {vuln['description']}")
                report.append("")
            
            elif analysis_type == "performance" and results.get("issues"):
                report.append("⚡ Performance Issues:")
                for issue in results["issues"]:
                    report.append(f"  • Line {issue.get('line', '?')}: {issue['description']}")
                report.append("")
            
            elif analysis_type == "style" and results.get("style_issues"):
                report.append("🎨 Style Issues:")
                for issue in results["style_issues"]:
                    report.append(f"  • Line {issue['line']}: {issue['message']}")
                report.append("")
        
        return "\n".join(report)

    def detect_code_patterns(self, code, language=None):
        """
        Detect common code patterns and anti-patterns
        
        Args:
            code (str): Source code to analyze
            language (str): Programming language (auto-detected if None)
            
        Returns:
            dict: Detected patterns and anti-patterns
        """
        try:
            if not language:
                language = self._detect_programming_language(code)
            
            patterns = {
                "design_patterns": [],
                "anti_patterns": [],
                "best_practices": [],
                "code_smells": []
            }
            
            # Detect design patterns
            if language == 'python':
                patterns.update(self._detect_python_patterns(code))
            elif language in ['javascript', 'typescript']:
                patterns.update(self._detect_javascript_patterns(code))
            
            return {
                "success": True,
                "language": language,
                "patterns": patterns
            }
            
        except Exception as e:
            return {"success": False, "error": f"Pattern detection failed: {str(e)}"}
    
    def _detect_python_patterns(self, code):
        """Detect Python-specific patterns"""
        patterns = {
            "design_patterns": [],
            "anti_patterns": [],
            "best_practices": [],
            "code_smells": []
        }
        
        # Singleton pattern
        if 'class ' in code and '__new__' in code:
            patterns["design_patterns"].append("Singleton Pattern detected")
        
        # Decorator pattern
        if '@' in code:
            patterns["design_patterns"].append("Decorator Pattern usage")
        
        # Context manager pattern
        if 'with ' in code and '__enter__' in code:
            patterns["design_patterns"].append("Context Manager Pattern")
        
        # Anti-patterns
        if 'global ' in code:
            patterns["anti_patterns"].append("Global variable usage")
        
        if 'exec(' in code or 'eval(' in code:
            patterns["anti_patterns"].append("Dynamic code execution")
        
        # Best practices
        if 'if __name__ == "__main__"' in code:
            patterns["best_practices"].append("Proper module execution guard")
        
        return patterns
    
    def _detect_javascript_patterns(self, code):
        """Detect JavaScript-specific patterns"""
        patterns = {
            "design_patterns": [],
            "anti_patterns": [],
            "best_practices": [],
            "code_smells": []
        }
        
        # Module pattern
        if 'function(' in code and 'return {' in code:
            patterns["design_patterns"].append("Module Pattern")
        
        # Observer pattern
        if 'addEventListener' in code or 'on(' in code:
            patterns["design_patterns"].append("Observer Pattern")
        
        # Anti-patterns
        if 'var ' in code:
            patterns["anti_patterns"].append("Use of 'var' instead of 'let'/'const'")
        
        if '== ' in code:
            patterns["anti_patterns"].append("Loose equality comparison")
        
        return patterns

# ========================= OPTIONAL TEST AND DEMO SECTION =========================
# Note: This section is optional and can be disabled for production use

def run_comprehensive_tests():
    """Run comprehensive tests of all JARVIS-X features (OPTIONAL)"""
    print("🚀 Starting JARVIS-X Comprehensive Test Suite")
    print("=" * 60)
    
    jarvis = JarvisAI()
    
    # Test 1: Basic AI Response
    print("\n1️⃣ Testing Basic AI Response...")
    try:
        response = jarvis.get_response("Hello JARVIS, introduce yourself briefly")
        print(f"✅ AI Response: {response[:100]}...")
    except Exception as e:
        print(f"❌ AI Response failed: {e}")
    
    # Test 2: Model Switching
    print("\n2️⃣ Testing Model Switching...")
    try:
        models = jarvis.list_available_models()
        print(f"✅ Available models: {len(models)} models found")
        
        # Switch to first available model
        if models:
            first_model = list(models.keys())[0]
            result = jarvis.set_model(first_model)
            print(f"✅ Model switch: {result}")
    except Exception as e:
        print(f"❌ Model switching failed: {e}")
    
    # Test 3: Personality Modes
    print("\n3️⃣ Testing Personality Modes...")
    try:
        personalities = ["standard", "professional", "sarcastic", "unleashed"]
        for personality in personalities:
            jarvis.set_personality(personality)
            print(f"✅ Personality '{personality}' set successfully")
    except Exception as e:
        print(f"❌ Personality switching failed: {e}")
    
    # Test 4: Memory System
    print("\n4️⃣ Testing Memory System...")
    try:
        # Test conversation history
        jarvis.add_to_conversation("user", "Test message for memory")
        history = jarvis.get_conversation_history(limit=1)
        print(f"✅ Memory system: {len(history)} entries retrieved")
        
        # Test preferences
        jarvis.update_user_preference("test_setting", "test_value")
        prefs = jarvis.get_user_preferences()
        print(f"✅ Preferences: {len(prefs)} preferences stored")
    except Exception as e:
        print(f"❌ Memory system failed: {e}")
    
    # Test 5: File Operations
    print("\n5️⃣ Testing File Operations...")
    try:
        # Test directory listing
        files = jarvis.list_directory("/workspaces/Jarves")
        print(f"✅ Directory listing: {len(files)} items found")
        
        # Test safe path validation
        safe_path = jarvis._validate_safe_path("/workspaces/Jarves/test_file.txt")
        print(f"✅ Path validation: {safe_path}")
        
        # Test file info
        file_info = jarvis.get_file_info("/workspaces/Jarves/README.md")
        if file_info.get("success"):
            print(f"✅ File info: README.md size = {file_info.get('size', 0)} bytes")
    except Exception as e:
        print(f"❌ File operations failed: {e}")
    
    # Test 6: Web Search
    print("\n6️⃣ Testing Web Search...")
    try:
        search_results = jarvis.web_search("Python programming", max_results=2)
        if search_results.get("success"):
            print(f"✅ Web search: {len(search_results.get('results', []))} results found")
        else:
            print(f"⚠️ Web search: {search_results.get('error', 'No results')}")
    except Exception as e:
        print(f"❌ Web search failed: {e}")
    
    # Test 7: Advanced Code Assistant
    print("\n7️⃣ Testing Advanced Code Assistant...")
    try:
        test_code = '''
def fibonacci(n):
    """Calculate fibonacci number"""
    if n <= 1:
        return n
    return fibonacci(n-1) + fibonacci(n-2)

def main():
    for i in range(10):
        print(f"F({i}) = {fibonacci(i)}")

if __name__ == "__main__":
    main()
'''
        
        # Run comprehensive code analysis
        analysis = jarvis.analyze_code(test_code, "test_fibonacci.py")
        if analysis.get("success"):
            print(f"✅ Code analysis: Language = {analysis.get('language')}")
            print(f"   Lines: {analysis.get('line_count')}, Score: {analysis.get('overall_assessment', {}).get('overall_score', 'N/A')}")
            
            # Test report formatting
            report = jarvis.format_analysis_report(analysis)
            print(f"✅ Analysis report: {len(report)} characters generated")
        else:
            print(f"❌ Code analysis failed: {analysis.get('error')}")
    except Exception as e:
        print(f"❌ Code assistant failed: {e}")
    
    # Test 8: Auto Personality Detection
    print("\n8️⃣ Testing Auto Personality...")
    try:
        # Enable auto personality
        jarvis.auto_personality = True
        
        # Test different message types
        test_messages = [
            "Can you help me with a professional report?",
            "Hey, what's up dude?",
            "I need serious help with debugging code",
            "Make me laugh with a joke"
        ]
        
        for msg in test_messages:
            personality = jarvis._detect_appropriate_personality(msg)
            print(f"✅ Auto personality: '{msg[:30]}...' → {personality}")
    except Exception as e:
        print(f"❌ Auto personality failed: {e}")
    
    # Test Summary
    print("\n" + "=" * 60)
    print("🎯 Test Suite Complete!")
    print("✅ All major features tested")
    print("💡 JARVIS-X is ready for Phase 4 (MCP Integration)")
    print("=" * 60)

def demo_advanced_features():
    """Demonstrate advanced JARVIS-X capabilities"""
    print("🎭 JARVIS-X Advanced Features Demo")
    print("=" * 50)
    
    jarvis = JarvisAI()
    
    # Demo 1: Multi-Model Conversation
    print("\n🤖 Demo 1: Multi-Model Intelligence")
    print("-" * 30)
    
    models = jarvis.list_available_models()
    print(f"Available AI Models: {len(models)}")
    for i, (name, info) in enumerate(list(models.items())[:3], 1):
        print(f"{i}. {name} ({info.get('price', 'Unknown pricing')})")
    
    # Demo 2: Intelligent Code Analysis
    print("\n🔍 Demo 2: Intelligent Code Analysis")
    print("-" * 30)
    
    demo_code = '''
import os
import hashlib

class UserManager:
    def __init__(self):
        self.users = {}
        self.admin_password = "admin123"  # Security issue!
    
    def add_user(self, username, password):
        # Potential SQL injection if used with database
        query = f"INSERT INTO users VALUES ('{username}', '{password}')"
        
        # Inefficient password hashing
        hashed = ""
        for char in password:
            hashed += str(ord(char))
        
        self.users[username] = hashed
        return True
    
    def authenticate(self, username, password):
        if username in self.users:
            # Inefficient nested loop
            for user in self.users:
                for stored_pass in [self.users[user]]:
                    if user == username:
                        return stored_pass == password
        return False
'''
    
    print("Analyzing demo code for security, performance, and style issues...")
    analysis = jarvis.analyze_code(demo_code, "user_manager.py", 
                                  ["security", "performance", "style", "complexity"])
    
    if analysis.get("success"):
        # Show formatted report
        report = jarvis.format_analysis_report(analysis)
        print(report)
    
    # Demo 3: Personality Adaptation
    print("\n🎭 Demo 3: Dynamic Personality Adaptation")
    print("-" * 30)
    
    jarvis.auto_personality = True
    
    demo_scenarios = [
        ("I'm working on a critical production bug and need help ASAP!", "emergency/professional"),
        ("Hey buddy, can you explain recursion in a fun way?", "casual/friendly"),
        ("Please provide a formal analysis of this algorithm's complexity", "professional/technical"),
        ("Roast my terrible code, don't hold back!", "sarcastic/humorous")
    ]
    
    for scenario, expected in demo_scenarios:
        detected = jarvis._detect_appropriate_personality(scenario)
        print(f"Scenario: '{scenario[:40]}...'")
        print(f"Detected Personality: {detected} (Expected: {expected})")
        print()
    
    # Demo 4: Advanced Memory System
    print("\n🧠 Demo 4: Persistent Memory & Learning")
    print("-" * 30)
    
    # Simulate learning user preferences
    learning_data = [
        ("programming_language", "Python"),
        ("preferred_code_style", "PEP8"),
        ("expertise_level", "intermediate"),
        ("project_type", "web_development"),
        ("ai_model_preference", "Llama-3.1"),
        ("response_style", "detailed_with_examples")
    ]
    
    print("Learning user preferences...")
    for key, value in learning_data:
        jarvis.update_user_preference(key, value)
        print(f"✅ Learned: {key} → {value}")
    
    print(f"\n📊 Total preferences stored: {len(jarvis.user_preferences)}")
    print(f"🎯 User identity: {jarvis.master_name} ({jarvis.master_title})")
    
    # Demo Summary
    print("\n" + "=" * 50)
    print("🚀 Demo Complete! JARVIS-X showcases:")
    print("  • Multi-model AI switching")
    print("  • Advanced code intelligence")
    print("  • Dynamic personality adaptation")
    print("  • Persistent learning & memory")
    print("  • Comprehensive security analysis")
    print("  • Performance optimization suggestions")
    print("=" * 50)

def interactive_demo():
    """Interactive demo for manual testing"""
    print("🎮 JARVIS-X Interactive Demo")
    print("Type 'help' for commands, 'quit' to exit")
    print("=" * 40)
    
    jarvis = JarvisAI()
    
    commands = {
        'help': 'Show available commands',
        'models': 'List available AI models',
        'switch <model>': 'Switch to specified model',
        'personality <mode>': 'Set personality mode',
        'analyze <file>': 'Analyze code file',
        'search <query>': 'Perform web search',
        'memory': 'Show memory statistics',
        'preferences': 'Show user preferences',
        'test': 'Run quick feature test',
        'quit': 'Exit demo'
    }
    
    while True:
        try:
            user_input = input("\n🤖 JARVIS> ").strip()
            
            if not user_input:
                continue
                
            parts = user_input.split(' ', 1)
            command = parts[0].lower()
            args = parts[1] if len(parts) > 1 else ""
            
            if command == 'quit':
                print("👋 Goodbye! JARVIS-X demo ended.")
                break
            
            elif command == 'help':
                print("\n📋 Available Commands:")
                for cmd, desc in commands.items():
                    print(f"  {cmd:20} - {desc}")
            
            elif command == 'models':
                models = jarvis.list_available_models()
                print(f"\n🤖 Available Models ({len(models)}):")
                for name, info in models.items():
                    status = "✅" if name == jarvis.current_model else "⚪"
                    print(f"  {status} {name} - {info.get('price', 'Unknown')}")
            
            elif command == 'switch' and args:
                result = jarvis.set_model(args)
                print(f"🔄 Model switch: {result}")
            
            elif command == 'personality' and args:
                jarvis.set_personality(args)
                print(f"🎭 Personality set to: {args}")
            
            elif command == 'analyze' and args:
                if os.path.exists(args):
                    with open(args, 'r') as f:
                        code = f.read()
                    analysis = jarvis.analyze_code(code, args)
                    report = jarvis.format_analysis_report(analysis)
                    print(f"\n{report}")
                else:
                    print(f"❌ File not found: {args}")
            
            elif command == 'search' and args:
                results = jarvis.web_search(args, max_results=3)
                if results.get("success"):
                    print(f"\n🔍 Search Results for '{args}':")
                    for i, result in enumerate(results.get("results", []), 1):
                        print(f"{i}. {result.get('title', 'No title')}")
                        print(f"   {result.get('url', 'No URL')}")
                else:
                    print(f"❌ Search failed: {results.get('error')}")
            
            elif command == 'memory':
                history_count = len(jarvis.conversation_history)
                prefs_count = len(jarvis.user_preferences)
                print(f"\n🧠 Memory Statistics:")
                print(f"  Conversation entries: {history_count}")
                print(f"  User preferences: {prefs_count}")
                print(f"  Master identity: {jarvis.master_name}")
            
            elif command == 'preferences':
                print(f"\n⚙️ User Preferences:")
                for key, value in jarvis.user_preferences.items():
                    if isinstance(value, dict):
                        print(f"  {key}: {list(value.keys())}")
                    else:
                        print(f"  {key}: {value}")
            
            elif command == 'test':
                print("\n🧪 Running Quick Test...")
                try:
                    response = jarvis.get_response("Say hello in exactly 5 words")
                    print(f"✅ AI Test: {response}")
                    
                    test_code = "def hello(): print('Hello World')"
                    analysis = jarvis.analyze_code(test_code)
                    print(f"✅ Code Analysis: {analysis.get('language', 'Unknown')} detected")
                    
                    search = jarvis.web_search("test query", max_results=1)
                    status = "✅" if search.get("success") else "⚠️"
                    print(f"{status} Web Search: {search.get('message', 'Completed')}")
                    
                except Exception as e:
                    print(f"❌ Test failed: {e}")
            
            else:
                print(f"❓ Unknown command: {command}")
                print("Type 'help' for available commands")
        
        except KeyboardInterrupt:
            print("\n\n👋 Demo interrupted. Goodbye!")
            break
        except Exception as e:
            print(f"❌ Error: {e}")

# ========================= MAIN EXECUTION =========================

if __name__ == "__main__":
    import sys
    
    print("🤖 JARVIS-X Advanced AI Assistant")
    print("Phase 3B: Advanced Code Assistant - COMPLETE ✅")
    print("Ready for Phase 4: MCP Integration 🚀")
    print("=" * 60)
    
    if len(sys.argv) > 1:
        command = sys.argv[1].lower()
        
        if command == "test":
            run_comprehensive_tests()
        elif command == "demo":
            demo_advanced_features()
        elif command == "interactive":
            interactive_demo()
        elif command == "version":
            print("JARVIS-X Version: 3.1 (Phase 3B Complete)")
            print("Features: Multi-Model AI, Advanced Code Assistant, Web Search, File Operations")
            print("Status: Ready for MCP Integration")
        else:
            print(f"Unknown command: {command}")
            print("Available commands: test, demo, interactive, version")
    else:
        print("Usage: python ai_engine.py [test|demo|interactive|version]")
        print("\nStarting interactive demo...")
        interactive_demo()

# ========================= VOICE INTERFACE INTEGRATION =========================

    def enable_voice_interface(self):
        """Enable voice interface if available"""
        try:
            # Try to import and create voice interface
            from .simple_voice_interface import create_simple_voice_interface
            
            if not hasattr(self, 'voice_interface') or self.voice_interface is None:
                self.voice_interface = create_simple_voice_interface(jarvis_ai=self)
            
            if self.voice_interface.enable_voice_interface():
                self.add_to_conversation("system", "Voice interface activated")
                return {
                    "success": True,
                    "message": "🎤 Voice interface activated. Say 'JARVIS' to begin voice conversation.",
                    "status": self.voice_interface.get_status()
                }
            else:
                return {
                    "success": False,
                    "error": "Failed to enable voice interface. Check audio system.",
                    "suggestions": [
                        "Ensure microphone is connected",
                        "Check audio permissions",
                        "Install required packages: pip install pyttsx3 speechrecognition"
                    ]
                }
                
        except ImportError as e:
            return {
                "success": False,
                "error": f"Voice interface not available: {str(e)}",
                "suggestions": [
                    "Install required packages: pip install pyttsx3 speechrecognition",
                    "Check voice_interface.py file exists"
                ]
            }
        except Exception as e:
            return {"success": False, "error": f"Voice interface error: {str(e)}"}
    
    def disable_voice_interface(self):
        """Disable voice interface"""
        try:
            if hasattr(self, 'voice_interface') and self.voice_interface:
                self.voice_interface.disable_voice_interface()
                self.add_to_conversation("system", "Voice interface deactivated")
                return {
                    "success": True,
                    "message": "💤 Voice interface deactivated"
                }
            else:
                return {
                    "success": False,
                    "error": "Voice interface not active"
                }
        except Exception as e:
            return {"success": False, "error": f"Error disabling voice interface: {str(e)}"}
    
    def get_voice_status(self):
        """Get voice interface status"""
        try:
            if hasattr(self, 'voice_interface') and self.voice_interface:
                return {
                    "success": True,
                    "voice_available": True,
                    "status": self.voice_interface.get_status()
                }
            else:
                return {
                    "success": True,
                    "voice_available": False,
                    "message": "Voice interface not initialized"
                }
        except Exception as e:
            return {"success": False, "error": f"Error getting voice status: {str(e)}"}
    
    def voice_command(self, command):
        """Process a voice command (for testing/simulation)"""
        try:
            # This allows testing voice commands via text
            self.add_to_conversation("user", f"[VOICE] {command}")
            
            # Process with adaptive personality based on voice context
            original_personality = self.personality_mode
            
            # Simple emotion detection for voice adaptation
            command_lower = command.lower()
            if any(word in command_lower for word in ['help', 'confused', 'explain']):
                self.switch_personality('genius')
            elif any(word in command_lower for word in ['frustrated', 'broken', 'wrong']):
                self.switch_personality('professional')
            elif any(word in command_lower for word in ['awesome', 'great', 'perfect']):
                self.switch_personality('unleashed')
            
            # Process the command
            response = self.chat(command)
            
            # Restore original personality
            self.switch_personality(original_personality)
            
            return {
                "success": True,
                "response": response,
                "personality_used": self.personality_mode,
                "original_personality": original_personality
            }
            
        except Exception as e:
            return {"success": False, "error": f"Voice command processing error: {str(e)}"}
    
    def test_voice_features(self):
        """Test voice interface features"""
        try:
            results = {
                "voice_commands_test": [],
                "personality_adaptation_test": [],
                "wake_word_detection_test": [],
                "overall_status": "pending"
            }
            
            # Test voice commands
            test_commands = [
                "Hello JARVIS",
                "Help me debug this error",
                "Explain this code to me",
                "This is awesome!",
                "I'm confused about functions"
            ]
            
            for cmd in test_commands:
                result = self.voice_command(cmd)
                results["voice_commands_test"].append({
                    "command": cmd,
                    "success": result["success"],
                    "personality_used": result.get("personality_used"),
                    "response_length": len(result.get("response", ""))
                })
            
            # Test personality adaptation
            personality_tests = [
                ("standard", "Hello JARVIS"),
                ("genius", "Explain machine learning"),
                ("professional", "Generate a project report"),
                ("sarcastic", "Why is my code not working?"),
                ("unleashed", "Let's build something amazing!")
            ]
            
            for personality, test_msg in personality_tests:
                original = self.personality_mode
                self.switch_personality(personality)
                response = self.chat(test_msg)
                results["personality_adaptation_test"].append({
                    "personality": personality,
                    "test_message": test_msg,
                    "response_contains_personality": len(response) > 10,
                    "switched_successfully": self.personality_mode == personality
                })
                self.switch_personality(original)
            
            # Test wake word detection logic
            try:
                from .simple_voice_interface import create_simple_voice_interface
                voice_test = create_simple_voice_interface()
                
                wake_tests = [
                    ("jarvis", True),
                    ("hey jarvis", True), 
                    ("jarvis are you there", True),
                    ("hello world", False),
                    ("not a wake word", False)
                ]
                
                for test_text, expected in wake_tests:
                    detected = any(wake in test_text.lower() for wake in voice_test.wake_words)
                    results["wake_word_detection_test"].append({
                        "text": test_text,
                        "expected": expected,
                        "detected": detected,
                        "correct": detected == expected
                    })
                
            except ImportError:
                results["wake_word_detection_test"] = ["Voice interface module not available"]
            
            # Determine overall status
            voice_cmd_success = sum(1 for t in results["voice_commands_test"] if t["success"])
            personality_success = sum(1 for t in results["personality_adaptation_test"] if t["switched_successfully"])
            wake_word_success = sum(1 for t in results["wake_word_detection_test"] if isinstance(t, dict) and t.get("correct"))
            
            total_tests = len(results["voice_commands_test"]) + len(results["personality_adaptation_test"]) + len([t for t in results["wake_word_detection_test"] if isinstance(t, dict)])
            total_passed = voice_cmd_success + personality_success + wake_word_success
            
            success_rate = (total_passed / total_tests) * 100 if total_tests > 0 else 0
            
            results["overall_status"] = {
                "success_rate": success_rate,
                "total_tests": total_tests,
                "tests_passed": total_passed,
                "voice_ready": success_rate >= 80
            }
            
            return {
                "success": True,
                "test_results": results,
                "summary": f"Voice features tested: {success_rate:.1f}% success rate ({total_passed}/{total_tests} tests passed)"
            }
            
        except Exception as e:
            return {"success": False, "error": f"Voice testing error: {str(e)}"}

    # Voice interface aliases for easy access
    def start_voice_mode(self):
        """Alias for enable_voice_interface"""
        return self.enable_voice_interface()
    
    def stop_voice_mode(self):
        """Alias for disable_voice_interface"""
        return self.disable_voice_interface()
    
    def voice_status(self):
        """Alias for get_voice_status"""
        return self.get_voice_status()
